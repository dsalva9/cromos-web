TASK: Implement Phase 3 Chat Improvements - Polish, Performance & Architecture

COMPLETED IN PREVIOUS PHASES:
âœ… Phase 1: Dynamic height, collapsible card, hide conversations, auto-scroll
âœ… Phase 2: Floating action button, ultra-minimal card

PHASE 3 GOALS:
1. Refactor into maintainable, reusable components
2. Add professional polish features (typing indicators, optimistic UI)
3. Optimize for tablets (split view)
4. Improve performance and error handling
5. Add quality-of-life improvements

FILES TO CREATE/MODIFY:
- src/components/chat/ChatInterface.tsx (new - unified component)
- src/components/chat/MessageList.tsx (new - extracted from page)
- src/components/chat/ChatComposer.tsx (new - extracted from page)
- src/components/chat/ConversationList.tsx (new - extracted from page)
- src/components/chat/TypingIndicator.tsx (new feature)
- src/hooks/chat/useChatActions.ts (new - business logic)
- src/hooks/chat/useChatUI.ts (new - UI state)
- src/hooks/chat/useTypingIndicator.ts (new - typing status)
- src/app/marketplace/[id]/chat/page.tsx (refactor to use new components)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PRIORITY 1: COMPONENT ARCHITECTURE REFACTOR (HIGH VALUE)

GOAL: Break down the monolithic 900-line page component into reusable pieces

STEP 1: CREATE TYPING INDICATOR COMPONENT

Create: src/components/chat/TypingIndicator.tsx

```tsx
'use client';

import { cn } from '@/lib/utils';

interface TypingIndicatorProps {
  userName?: string;
  className?: string;
}

export function TypingIndicator({ userName, className }: TypingIndicatorProps) {
  return (
    <div className={cn('flex items-center gap-2 text-gray-400 text-sm', className)}>
      <div className="flex gap-1">
        <span className="animate-bounce [animation-delay:-0.3s]">â—</span>
        <span className="animate-bounce [animation-delay:-0.15s]">â—</span>
        <span className="animate-bounce">â—</span>
      </div>
      <span>{userName || 'Usuario'} estÃ¡ escribiendo...</span>
    </div>
  );
}
```

Add to tailwind.config.js if bounce animation needs tweaking:
```js
animation: {
  bounce: 'bounce 1.4s ease-in-out infinite',
}
```

STEP 2: CREATE TYPING INDICATOR HOOK

Create: src/hooks/chat/useTypingIndicator.ts

```tsx
import { useState, useEffect, useCallback } from 'react';
import { useSupabaseClient } from '@/components/providers/SupabaseProvider';

interface UseTypingIndicatorProps {
  listingId: number;
  userId?: string;
  participantId?: string;
}

export function useTypingIndicator({
  listingId,
  userId,
  participantId,
}: UseTypingIndicatorProps) {
  const supabase = useSupabaseClient();
  const [isTyping, setIsTyping] = useState(false);
  const [typingUser, setTypingUser] = useState<{ id: string; nickname: string } | null>(null);
  const [typingTimeout, setTypingTimeout] = useState<NodeJS.Timeout | null>(null);

  // Subscribe to typing indicators from other users
  useEffect(() => {
    if (!userId || !listingId) return;

    const channel = supabase.channel(`chat:${listingId}:typing`);

    channel
      .on('broadcast', { event: 'typing' }, (payload) => {
        const { userId: typingUserId, nickname, isTyping: typing } = payload.payload;

        // Ignore own typing events
        if (typingUserId === userId) return;

        // If looking at specific participant, only show their typing
        if (participantId && typingUserId !== participantId) return;

        if (typing) {
          setIsTyping(true);
          setTypingUser({ id: typingUserId, nickname });
        } else {
          setIsTyping(false);
          setTypingUser(null);
        }
      })
      .subscribe();

    return () => {
      void supabase.removeChannel(channel);
    };
  }, [listingId, userId, participantId, supabase]);

  // Send typing indicator
  const sendTypingIndicator = useCallback(
    async (typing: boolean, nickname: string) => {
      if (!userId || !listingId) return;

      const channel = supabase.channel(`chat:${listingId}:typing`);

      await channel.send({
        type: 'broadcast',
        event: 'typing',
        payload: { userId, nickname, isTyping: typing },
      });
    },
    [listingId, userId, supabase]
  );

  // Debounced typing indicator
  const handleTyping = useCallback(
    (nickname: string) => {
      // Clear existing timeout
      if (typingTimeout) {
        clearTimeout(typingTimeout);
      }

      // Send typing start
      void sendTypingIndicator(true, nickname);

      // Set timeout to send typing stop after 3 seconds
      const timeout = setTimeout(() => {
        void sendTypingIndicator(false, nickname);
      }, 3000);

      setTypingTimeout(timeout);
    },
    [typingTimeout, sendTypingIndicator]
  );

  // Stop typing indicator
  const stopTyping = useCallback(
    (nickname: string) => {
      if (typingTimeout) {
        clearTimeout(typingTimeout);
        setTypingTimeout(null);
      }
      void sendTypingIndicator(false, nickname);
    },
    [typingTimeout, sendTypingIndicator]
  );

  return {
    isTyping,
    typingUser,
    handleTyping,
    stopTyping,
  };
}
```

STEP 3: CREATE MESSAGE LIST COMPONENT

Create: src/components/chat/MessageList.tsx

```tsx
'use client';

import { cn } from '@/lib/utils';
import Link from 'next/link';
import { RefObject } from 'react';
import { TypingIndicator } from './TypingIndicator';

interface Message {
  id: string;
  sender_id: string | null;
  sender_nickname?: string;
  message: string;
  created_at: string;
  is_system: boolean;
}

interface MessageListProps {
  messages: Message[];
  currentUserId?: string;
  isOwner?: boolean;
  selectedParticipant?: string | null;
  messagesEndRef: RefObject<HTMLDivElement>;
  height?: string;
  isTyping?: boolean;
  typingUserName?: string;
  emptyMessage?: string;
  children?: React.ReactNode; // For rating UI, etc.
}

export function MessageList({
  messages,
  currentUserId,
  isOwner,
  selectedParticipant,
  messagesEndRef,
  height = '500px',
  isTyping,
  typingUserName,
  emptyMessage,
  children,
}: MessageListProps) {
  if (isOwner && !selectedParticipant) {
    return (
      <div className="flex items-center justify-center h-full">
        <p className="text-gray-400">
          Selecciona una conversaciÃ³n para ver los mensajes
        </p>
      </div>
    );
  }

  if (messages.length === 0) {
    return (
      <div className="flex items-center justify-center h-full">
        <p className="text-gray-400">
          {emptyMessage || (isOwner
            ? 'No hay mensajes en esta conversaciÃ³n'
            : 'EnvÃ­a un mensaje para iniciar la conversaciÃ³n')}
        </p>
      </div>
    );
  }

  return (
    <div className="overflow-y-auto p-4 space-y-3" style={{ height }}>
      {messages.map(message => {
        // System messages
        if (message.is_system) {
          return (
            <div key={message.id} className="flex justify-center my-4">
              <div className="bg-gray-700/50 text-gray-300 rounded-lg px-4 py-2 text-sm text-center max-w-[80%] border border-gray-600">
                <p className="italic">{message.message}</p>
                <p className="text-xs mt-1 opacity-60">
                  {new Date(message.created_at).toLocaleTimeString('es-ES', {
                    hour: '2-digit',
                    minute: '2-digit',
                  })}
                </p>
              </div>
            </div>
          );
        }

        // Regular user messages
        const isOwnMessage = message.sender_id === currentUserId;
        return (
          <div
            key={message.id}
            className={cn('flex', isOwnMessage ? 'justify-end' : 'justify-start')}
          >
            <div
              className={cn(
                'max-w-[70%] rounded-lg p-3 border-2 border-black',
                isOwnMessage ? 'bg-[#FFC000] text-black' : 'bg-gray-800 text-white'
              )}
            >
              {!isOwnMessage && message.sender_nickname && (
                <p className="text-xs font-bold mb-1 opacity-70">
                  {message.sender_id ? (
                    <Link
                      href={`/users/${message.sender_id}`}
                      className="hover:text-[#FFC000] hover:underline transition-colors"
                    >
                      {message.sender_nickname}
                    </Link>
                  ) : (
                    message.sender_nickname
                  )}
                </p>
              )}
              <p className="whitespace-pre-wrap break-words">{message.message}</p>
              <p className="text-xs mt-1 opacity-60">
                {new Date(message.created_at).toLocaleTimeString('es-ES', {
                  hour: '2-digit',
                  minute: '2-digit',
                })}
              </p>
            </div>
          </div>
        );
      })}

      {/* Additional content (like rating UI) */}
      {children}

      {/* Typing indicator */}
      {isTyping && <TypingIndicator userName={typingUserName} className="ml-4" />}

      <div ref={messagesEndRef} />
    </div>
  );
}
```

STEP 4: CREATE CHAT COMPOSER COMPONENT

Create: src/components/chat/ChatComposer.tsx

```tsx
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Send } from 'lucide-react';
import { Checkbox } from '@/components/ui/checkbox';
import { cn } from '@/lib/utils';

interface ChatComposerProps {
  onSend: (message: string) => Promise<void>;
  disabled?: boolean;
  sending?: boolean;
  placeholder?: string;
  maxLength?: number;
  disabledMessage?: string;
  requireTosAcceptance?: boolean;
  tosAccepted?: boolean;
  onTosAcceptChange?: (accepted: boolean) => void;
  onTosClick?: () => void;
  onTyping?: () => void;
  onStopTyping?: () => void;
  className?: string;
}

export function ChatComposer({
  onSend,
  disabled = false,
  sending = false,
  placeholder = 'Escribe un mensaje...',
  maxLength = 500,
  disabledMessage,
  requireTosAcceptance = false,
  tosAccepted = false,
  onTosAcceptChange,
  onTosClick,
  onTyping,
  onStopTyping,
  className,
}: ChatComposerProps) {
  const [messageText, setMessageText] = useState('');

  const handleSend = async () => {
    if (!messageText.trim() || sending || disabled) return;

    await onSend(messageText);
    setMessageText('');
    onStopTyping?.();
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      void handleSend();
    }
  };

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setMessageText(e.target.value);
    onTyping?.();
  };

  if (disabled && disabledMessage) {
    return (
      <div className={cn('border-t-2 border-gray-700 p-4', className)}>
        <p className="text-gray-400 text-center italic">{disabledMessage}</p>
      </div>
    );
  }

  return (
    <div className={cn('border-t-2 border-gray-700 p-4', className)}>
      {/* ToS acceptance */}
      {requireTosAcceptance && (
        <div className="mb-4 p-3 bg-gray-800 rounded-md border border-gray-700">
          <div className="flex items-start gap-3">
            <Checkbox
              id="tos-chat"
              checked={tosAccepted}
              onCheckedChange={(checked) => onTosAcceptChange?.(checked === true)}
            />
            <label
              htmlFor="tos-chat"
              className="text-sm text-gray-300 cursor-pointer leading-relaxed"
            >
              Acepto los{' '}
              <button
                type="button"
                onClick={onTosClick}
                className="text-[#FFC000] hover:underline font-semibold"
              >
                tÃ©rminos y condiciones
              </button>{' '}
              y me comprometo a realizar intercambios de manera honesta y respetuosa.
            </label>
          </div>
        </div>
      )}

      {/* Input area */}
      <div className="flex gap-2">
        <textarea
          value={messageText}
          onChange={handleChange}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          maxLength={maxLength}
          rows={2}
          className="flex-1 bg-gray-800 text-white rounded-md px-4 py-2 border-2 border-gray-700 focus:border-[#FFC000] focus:outline-none resize-none disabled:opacity-50 disabled:cursor-not-allowed"
          disabled={sending || disabled}
        />
        <Button
          onClick={handleSend}
          disabled={!messageText.trim() || sending || disabled}
          className="bg-[#FFC000] text-black hover:bg-yellow-400 font-bold"
        >
          <Send className="h-4 w-4" />
        </Button>
      </div>
      <p className="text-xs text-gray-500 mt-2">
        {messageText.length}/{maxLength} caracteres
      </p>
    </div>
  );
}
```

STEP 5: CREATE CONVERSATION LIST COMPONENT

Create: src/components/chat/ConversationList.tsx

```tsx
'use client';

import { cn } from '@/lib/utils';

interface Participant {
  user_id: string;
  nickname: string;
  last_message?: string;
  unread_count: number;
}

interface ConversationListProps {
  participants: Participant[];
  selectedParticipant?: string | null;
  onSelectParticipant: (userId: string) => void;
  reservedForUserId?: string | null;
  title?: string;
  className?: string;
}

export function ConversationList({
  participants,
  selectedParticipant,
  onSelectParticipant,
  reservedForUserId,
  title = 'Conversaciones',
  className,
}: ConversationListProps) {
  if (participants.length === 0) {
    return (
      <div className={cn('p-4', className)}>
        <h3 className="font-bold text-white mb-3">{title}</h3>
        <p className="text-sm text-gray-400">No hay conversaciones aÃºn</p>
      </div>
    );
  }

  return (
    <div className={cn('p-4', className)}>
      <h3 className="font-bold text-white mb-3">
        {title} {participants.length > 0 && `(${participants.length})`}
      </h3>
      <div className="space-y-2">
        {participants.map((participant) => {
          const isReservedForThis = reservedForUserId === participant.user_id;

          return (
            <button
              key={participant.user_id}
              onClick={() => onSelectParticipant(participant.user_id)}
              className={cn(
                'w-full text-left p-3 rounded-md transition-colors',
                selectedParticipant === participant.user_id
                  ? 'bg-[#FFC000]/20 border-2 border-[#FFC000]'
                  : 'bg-gray-800 hover:bg-gray-700 border-2 border-transparent'
              )}
            >
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2 flex-1 min-w-0">
                  <span className="font-bold text-white truncate">
                    {participant.nickname}
                  </span>
                  {isReservedForThis && (
                    <span className="bg-yellow-900/30 text-yellow-400 text-xs font-bold px-1.5 py-0.5 rounded flex-shrink-0">
                      Reservado
                    </span>
                  )}
                </div>
                {participant.unread_count > 0 && (
                  <span className="bg-[#FFC000] text-black text-xs font-bold px-2 py-0.5 rounded-full flex-shrink-0">
                    {participant.unread_count}
                  </span>
                )}
              </div>
              {participant.last_message && (
                <p className="text-sm text-gray-400 truncate mt-1">
                  {participant.last_message}
                </p>
              )}
            </button>
          );
        })}
      </div>
    </div>
  );
}
```

STEP 6: REFACTOR CHAT PAGE TO USE NEW COMPONENTS

In src/app/marketplace/[id]/chat/page.tsx:

A. Add imports:
```tsx
import { MessageList } from '@/components/chat/MessageList';
import { ChatComposer } from '@/components/chat/ChatComposer';
import { ConversationList } from '@/components/chat/ConversationList';
import { useTypingIndicator } from '@/hooks/chat/useTypingIndicator';
```

B. Add typing indicator hook (after other hooks):
```tsx
const { isTyping, typingUser, handleTyping, stopTyping } = useTypingIndicator({
  listingId,
  userId: user?.id,
  participantId: selectedParticipant || undefined,
});
```

C. Update handleSend to stop typing:
```tsx
const handleSend = async (messageText: string) => {
  if (!messageText.trim() || sending) return;

  // Check ToS acceptance for buyers sending first message
  if (!isOwner && messages.length === 0 && !tosAccepted) {
    toast.error('Debes aceptar los tÃ©rminos y condiciones antes de enviar un mensaje');
    return;
  }

  const receiverId = isOwner
    ? selectedParticipant || undefined
    : listingOwner || undefined;

  await sendMessage(messageText, receiverId);

  // Stop typing indicator after sending
  stopTyping(user?.email || 'Usuario');
};
```

D. Replace the messages section (lines ~634-758) with:
```tsx
<MessageList
  messages={messages}
  currentUserId={user?.id}
  isOwner={isOwner}
  selectedParticipant={selectedParticipant}
  messagesEndRef={messagesEndRef}
  height={chatHeight}
  isTyping={isTyping}
  typingUserName={typingUser?.nickname}
  emptyMessage={
    isOwner
      ? 'No hay mensajes en esta conversaciÃ³n'
      : 'EnvÃ­a un mensaje para iniciar la conversaciÃ³n'
  }
>
  {/* Rating UI - shown when transaction is completed */}
  {listing?.status === 'completed' && counterpartyToRate && (
    <div className="flex justify-center my-4">
      {!myRating ? (
        <button
          onClick={() => setShowRatingModal(true)}
          className="bg-gray-700/50 text-white rounded-lg px-6 py-3 text-sm border border-[#FFC000] hover:bg-gray-700 transition-colors"
        >
          â­ Haz clic aquÃ­ para valorar a {counterpartyToRate.nickname}
        </button>
      ) : (
        <div className="bg-gray-700/50 text-gray-300 rounded-lg px-4 py-2 text-sm text-center max-w-[80%] border border-gray-600">
          <p>
            Has valorado a {counterpartyToRate.nickname} con{' '}
            {'â­'.repeat(myRating.rating)} ({myRating.rating}/5)
            {myRating.comment && ` y has comentado: "${myRating.comment}"`}
          </p>
        </div>
      )}
    </div>
  )}

  {/* Show counterparty's rating when both have rated */}
  {listing?.status === 'completed' && bothRated && counterpartyRating && (
    <div className="flex justify-center my-4">
      <div className="bg-gray-700/50 text-gray-300 rounded-lg px-4 py-2 text-sm text-center max-w-[80%] border border-gray-600">
        <p>
          {isOwner ? 'El comprador' : 'El vendedor'} te ha valorado con{' '}
          {'â­'.repeat(counterpartyRating.rating)} ({counterpartyRating.rating}/5)
          {counterpartyRating.comment && ` y ha comentado: "${counterpartyRating.comment}"`}
        </p>
      </div>
    </div>
  )}
</MessageList>
```

E. Replace the composer section (lines ~760-836) with:
```tsx
<ChatComposer
  onSend={handleSend}
  disabled={
    listingAccessDenied ||
    (listing?.status === 'completed' && !isReservedBuyer && !isOwner) ||
    (listing?.status === 'reserved' && !isReservedBuyer && !isOwner) ||
    (isOwner && !selectedParticipant && participants.length > 0)
  }
  sending={sending}
  placeholder="Escribe un mensaje..."
  maxLength={500}
  disabledMessage={
    listingAccessDenied && !isOwner
      ? 'No tienes acceso a este chat'
      : listing?.status === 'completed' && !isReservedBuyer && !isOwner
      ? 'Este anuncio ya no estÃ¡ disponible'
      : listing?.status === 'completed' && (isReservedBuyer || isOwner)
      ? 'Chat cerrado - La transacciÃ³n ha sido completada'
      : listing?.status === 'reserved' && !isReservedBuyer && !isOwner
      ? 'Este anuncio estÃ¡ reservado para otro usuario'
      : isOwner && !selectedParticipant && participants.length > 0
      ? 'Selecciona una conversaciÃ³n para responder'
      : undefined
  }
  requireTosAcceptance={!isOwner && messages.length === 0}
  tosAccepted={tosAccepted}
  onTosAcceptChange={setTosAccepted}
  onTosClick={() => setChatTermsDialogOpen(true)}
  onTyping={() => handleTyping(user?.email || 'Usuario')}
  onStopTyping={() => stopTyping(user?.email || 'Usuario')}
/>
```

F. Replace desktop conversation list sidebar (around line 573):
```tsx
<div className="hidden md:block md:col-span-1">
  <ModernCard>
    <ModernCardContent className="p-0">
      <ConversationList
        participants={participants}
        selectedParticipant={selectedParticipant}
        onSelectParticipant={setSelectedParticipant}
        reservedForUserId={transaction?.buyer_id}
      />
    </ModernCardContent>
  </ModernCard>
</div>
```

G. Replace mobile conversation list (the one that shows/hides):
```tsx
{showConversationList || !selectedParticipant ? (
  <div className="mb-6">
    <ModernCard>
      <ModernCardContent className="p-0">
        <ConversationList
          participants={participants}
          selectedParticipant={selectedParticipant}
          onSelectParticipant={(userId) => {
            setSelectedParticipant(userId);
            setShowConversationList(false);
          }}
          reservedForUserId={transaction?.buyer_id}
        />
      </ModernCardContent>
    </ModernCard>
  </div>
) : (
  <button
    onClick={() => setShowConversationList(true)}
    className="flex items-center gap-2 mb-4 text-[#FFC000] hover:text-yellow-400 transition-colors"
  >
    <ArrowLeft className="h-4 w-4" />
    <span className="text-sm font-bold">Conversaciones ({participants.length})</span>
  </button>
)}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PRIORITY 2: TABLET SPLIT VIEW (MEDIUM IMPACT)

GOAL: Better use of tablet screen space (768px - 1024px)

IMPLEMENTATION:

In src/app/marketplace/[id]/chat/page.tsx, update the grid layout:

```tsx
<div className={cn(
  'grid gap-6',
  // Mobile: Single column
  'grid-cols-1',
  // Tablet landscape: 2 columns if seller with participants
  'md:grid-cols-2',
  // Desktop: 3 columns if seller with participants, otherwise full width
  isOwner && participants.length > 0 && 'lg:grid-cols-3'
)}>
  {/* Sidebar - hidden on mobile when chat selected */}
  {isOwner && participants.length > 0 && (
    <div className={cn(
      // Mobile: Full width, conditionally hidden
      showConversationList || !selectedParticipant ? 'block' : 'hidden',
      // Tablet+: Always show as sidebar
      'md:block md:col-span-1'
    )}>
      {/* Conversation list */}
    </div>
  )}

  {/* Chat panel */}
  <div className={cn(
    // Mobile: Full width when visible
    !showConversationList && selectedParticipant ? 'block' : 'hidden md:block',
    // Tablet: Take remaining space
    isOwner && participants.length > 0
      ? 'md:col-span-1 lg:col-span-2'
      : 'md:col-span-2 lg:col-span-3'
  )}>
    {/* Chat messages and composer */}
  </div>
</div>
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PRIORITY 3: OPTIMISTIC UI UPDATES (HIGH POLISH)

GOAL: Show messages immediately before server confirms

UPDATE useListingChat hook in src/hooks/marketplace/useListingChat.ts:

Add optimistic message state:
```tsx
const [optimisticMessages, setOptimisticMessages] = useState<Message[]>([]);

// Combine real and optimistic messages
const allMessages = useMemo(() => {
  return [...messages, ...optimisticMessages].sort((a, b) =>
    new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
  );
}, [messages, optimisticMessages]);
```

Update sendMessage:
```tsx
const sendMessage = async (message: string, receiverId?: string) => {
  if (!user) return;

  setSending(true);

  // Create optimistic message
  const tempId = `temp-${Date.now()}`;
  const optimisticMsg: Message = {
    id: tempId,
    sender_id: user.id,
    sender_nickname: user.email?.split('@')[0] || 'TÃº',
    receiver_id: receiverId || null,
    listing_id: listingId,
    message: message.trim(),
    created_at: new Date().toISOString(),
    is_system: false,
    is_read: false,
  };

  // Add to optimistic messages immediately
  setOptimisticMessages(prev => [...prev, optimisticMsg]);

  try {
    const { data, error } = await supabase.rpc('send_listing_message', {
      p_listing_id: listingId,
      p_receiver_id: receiverId || null,
      p_message: message.trim(),
    });

    if (error) throw error;

    // Remove optimistic message after successful send
    setOptimisticMessages(prev => prev.filter(m => m.id !== tempId));

    // Real message will come through realtime subscription
  } catch (error) {
    console.error('Error sending message:', error);
    toast.error('Error al enviar el mensaje');

    // Remove failed optimistic message
    setOptimisticMessages(prev => prev.filter(m => m.id !== tempId));
  } finally {
    setSending(false);
  }
};
```

Return allMessages instead of messages:
```tsx
return {
  messages: allMessages, // Changed from just messages
  participants,
  loading,
  sending,
  sendMessage,
  fetchParticipants,
  messagesEndRef,
};
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PRIORITY 4: BETTER ERROR HANDLING & LOADING STATES

ADD LOADING SKELETON:

Create: src/components/chat/ChatSkeleton.tsx

```tsx
export function ChatSkeleton() {
  return (
    <div className="animate-pulse p-4 space-y-4">
      {/* Message skeletons */}
      {[1, 2, 3].map((i) => (
        <div
          key={i}
          className={i % 2 === 0 ? 'flex justify-end' : 'flex justify-start'}
        >
          <div className="bg-gray-700 h-16 w-64 rounded-lg" />
        </div>
      ))}
    </div>
  );
}
```

Use in chat page:
```tsx
{loading && messages.length === 0 ? (
  <ChatSkeleton />
) : (
  <MessageList {...props} />
)}
```

ADD ERROR BOUNDARY:

Create: src/components/chat/ChatErrorBoundary.tsx

```tsx
'use client';

import { Component, ReactNode } from 'react';
import { Button } from '@/components/ui/button';
import { AlertCircle } from 'lucide-react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ChatErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="flex flex-col items-center justify-center p-8 text-center">
          <AlertCircle className="h-12 w-12 text-red-500 mb-4" />
          <h3 className="text-lg font-bold text-white mb-2">
            Error al cargar el chat
          </h3>
          <p className="text-gray-400 mb-4">
            {this.state.error?.message || 'Algo saliÃ³ mal'}
          </p>
          <Button
            onClick={() => window.location.reload()}
            className="bg-[#FFC000] text-black hover:bg-yellow-400"
          >
            Recargar pÃ¡gina
          </Button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

Wrap chat page content:
```tsx
<ChatErrorBoundary>
  {/* All chat UI */}
</ChatErrorBoundary>
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PRIORITY 5: PERFORMANCE OPTIMIZATIONS

A. LAZY LOAD LISTING IMAGE:
```tsx
import Image from 'next/image';

<Image
  src={listing.image_url}
  alt={listing.title}
  fill
  loading="lazy"
  className="object-cover rounded-md"
/>
```

B. MEMOIZE EXPENSIVE COMPONENTS:
```tsx
import { memo } from 'react';

export const MessageList = memo(function MessageList(props) {
  // Component code
});
```

C. DEBOUNCE TYPING INDICATOR (already in hook)

D. VIRTUALIZE LONG MESSAGE LISTS (only if needed):
If conversations exceed 100 messages, consider react-window:
```bash
npm install react-window
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TESTING CHECKLIST:

Components:
- [ ] MessageList renders all message types correctly
- [ ] ChatComposer sends messages on Enter
- [ ] ConversationList shows correct selected state
- [ ] TypingIndicator animates smoothly
- [ ] FloatingActionMenu works from Phase 2

Features:
- [ ] Typing indicator appears when other user types
- [ ] Typing indicator disappears after 3 seconds
- [ ] Optimistic UI shows message immediately
- [ ] Message appears permanently after server confirms
- [ ] Failed messages are removed with error toast
- [ ] Skeleton shows while loading
- [ ] Error boundary catches render errors

Responsive:
- [ ] Mobile (375px): Single column, optimized
- [ ] Tablet portrait (768px): 2-column split view
- [ ] Tablet landscape (1024px): 3-column for sellers
- [ ] Desktop (1280px+): All features visible

Performance:
- [ ] No unnecessary re-renders
- [ ] Smooth scrolling with 50+ messages
- [ ] Typing indicator doesn't cause lag
- [ ] Images load progressively

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EXPECTED RESULTS:

Architecture:
- Page component: 900 lines â†’ ~400 lines
- Reusable components: 0 â†’ 5 new components
- Custom hooks: 2 â†’ 4 hooks
- Maintainability: Much improved

Features:
- Typing indicators: Professional feel
- Optimistic UI: Instant feedback
- Better loading: No blank screens
- Error handling: Graceful failures

Performance:
- Initial load: Unchanged
- Message send: Feels instant (optimistic UI)
- Typing: Smooth, no stuttering
- Scrolling: Smooth with many messages

UX:
- Tablet experience: Much improved with split view
- Mobile: Already great from Phase 1 & 2
- Desktop: Unchanged, already good
- Overall: Polished, professional

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ROLLBACK PLAN:

Each component is separate, can rollback individually:
- Don't like typing indicators? Remove the hook
- Issues with optimistic UI? Keep original sendMessage
- Split view problems? Revert to original grid
- Component bugs? Use inline code temporarily

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FILES SUMMARY:

NEW FILES (10):
1. src/components/chat/TypingIndicator.tsx
2. src/components/chat/MessageList.tsx
3. src/components/chat/ChatComposer.tsx
4. src/components/chat/ConversationList.tsx
5. src/components/chat/ChatSkeleton.tsx
6. src/components/chat/ChatErrorBoundary.tsx
7. src/components/chat/FloatingActionMenu.tsx (Phase 2)
8. src/hooks/chat/useTypingIndicator.ts
9. src/hooks/chat/useChatActions.ts (optional)
10. src/hooks/chat/useChatUI.ts (optional)

MODIFIED FILES (2):
1. src/app/marketplace/[id]/chat/page.tsx (refactor to use components)
2. src/hooks/marketplace/useListingChat.ts (add optimistic UI)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TOTAL EFFORT ESTIMATE:

- Component extraction: 2-3 hours
- Typing indicator: 1-2 hours
- Optimistic UI: 1 hour
- Tablet split view: 1 hour
- Error handling: 1 hour
- Testing: 2 hours

TOTAL: 8-10 hours (1-2 days)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

AFTER THIS PHASE:

Your chat will be:
âœ… Mobile-optimized (Phase 1)
âœ… Ultra-clean with FAB (Phase 2)
âœ… Well-architected (Phase 3)
âœ… Professional features (Phase 3)
âœ… Tablet-optimized (Phase 3)
âœ… Performant (Phase 3)
âœ… Maintainable (Phase 3)

FUTURE POSSIBILITIES:
ğŸ”® Rich media (images, voice)
ğŸ”® Read receipts
ğŸ”® Message search
ğŸ”® Chat templates
ğŸ”® Quick replies
