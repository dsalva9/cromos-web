# Database Schema Documentation

## Current State: v1.5.0 (Critical Fixes + Admin + Location Matching + Badges + Quick Entry + Avatars)

Last updated: 2025-10-10
Source: Planned schema for v1.5.0 (pre-implementation)

## Overview

The CambioCromos database consists of 17 tables supporting:

- User authentication and profiles
- **Admin role-based access control (v1.5.0)**
- **Location-based matching with Haversine distance (v1.5.0)**
- Multi-collection sticker management
- Album-style page navigation (v1.3.0)
- Complete trading proposal system
- Trade history and chat
- Trade finalization handshake (v1.4.4)
- Notifications system (v1.4.4)
- User badges and achievements
- **Admin audit log (v1.5.0)**
- **Postal codes centroid data (v1.5.0)**

---

## Core Tables

### `profiles`

User profiles extending Supabase Auth.

```sql
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  nickname TEXT,
  avatar_url TEXT,
  is_admin BOOLEAN DEFAULT FALSE, -- v1.5.0: Admin role flag
  postcode TEXT NULL, -- v1.5.0: Optional postcode for location-based matching
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**v1.5.0 Additions:**
- `is_admin`: Boolean flag for admin access. Used with JWT claims enforcement in SECURITY DEFINER RPCs.
- `postcode`: Optional postcode (e.g., "28001") for location-based trade matching. Privacy-preserving (no exact address).

**Indexes:**

- Primary key on `id`

**RLS Policies:**

- Users can read all profiles
- Users can only update their own profile
- `is_admin` column is protected: only admins can modify it (enforced via RPC + JWT claims)

---

### `collections`

Sticker collections (e.g., "UEFA Euro 2024", "Liga 2024/25").

```sql
CREATE TABLE collections (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  name TEXT NOT NULL,
  competition TEXT NOT NULL,
  year TEXT NOT NULL,
  description TEXT,
  image_url TEXT,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Indexes:**

- Primary key on `id`
- `idx_collections_active` on `(is_active)`

**RLS Policies:**

- Public read access
- Admin-only write access

---

### `collection_teams`

Teams within each collection.

```sql
CREATE TABLE collection_teams (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER REFERENCES collections(id) ON DELETE CASCADE,
  team_name TEXT NOT NULL,
  team_code TEXT,
  logo_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Indexes:**

- Primary key on `id`
- `idx_collection_teams_collection` on `(collection_id)`
- `idx_collection_teams_name` on `(team_name)` for trading queries

**RLS Policies:**

- Public read access
- Admin-only write access

---

### `stickers`

Individual stickers within collections.

```sql
CREATE TABLE stickers (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER REFERENCES collections(id) ON DELETE CASCADE,
  team_id INTEGER REFERENCES collection_teams(id) ON DELETE SET NULL,
  code TEXT NOT NULL,
  player_name TEXT NOT NULL,
  position TEXT,
  nationality TEXT,
  rating INTEGER,
  rarity TEXT CHECK (rarity IN ('common', 'rare', 'epic', 'legendary')),
  image_url TEXT,
  sticker_number INTEGER,
  image_path_webp_300 TEXT,
  thumb_path_webp_100 TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),

  CONSTRAINT unique_sticker_code UNIQUE (collection_id, code)
);
```

**New in v1.3.0:**

- `sticker_number`: Unique sequential number within collection
- `image_path_webp_300`: Path to full-size WebP image in Supabase Storage
- `thumb_path_webp_100`: Path to 100px thumbnail in Supabase Storage

**Indexes:**

- Primary key on `id`
- `idx_stickers_collection` on `(collection_id)`
- `idx_stickers_collection_filters` on `(collection_id, rarity, team_id, player_name)` for trading
- `idx_stickers_collection_number_unique` (partial) on `(collection_id, sticker_number)` WHERE `sticker_number IS NOT NULL`

**RLS Policies:**

- Public read access
- Admin-only write access

---

### `user_collections`

Tracks which collections users have joined and which is active.

```sql
CREATE TABLE user_collections (
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  collection_id INTEGER REFERENCES collections(id) ON DELETE CASCADE,
  is_active BOOLEAN DEFAULT false,
  joined_at TIMESTAMPTZ DEFAULT NOW(),

  PRIMARY KEY (user_id, collection_id),
  CONSTRAINT unique_active_per_user
    UNIQUE (user_id, is_active)
    WHERE (is_active = true)
);
```

**Constraints:**

- Only one active collection per user (partial unique constraint)

**Indexes:**

- Primary key on `(user_id, collection_id)`

**RLS Policies:**

- Users can only access their own collection memberships



---

### `user_stickers`

User's sticker inventory.

```sql
CREATE TABLE user_stickers (
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  sticker_id INTEGER REFERENCES stickers(id) ON DELETE CASCADE,
  count INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  PRIMARY KEY (user_id, sticker_id)
);
```

**Indexes:**

- Primary key on `(user_id, sticker_id)`
- `idx_user_stickers_trading_v2` on `(sticker_id, user_id, count)` for duplicate-driven trading queries
- `idx_user_stickers_user_collection_sticker` on `(user_id, collection_id, sticker_id)` for fast user inventory lookups
- `idx_user_stickers_user_collection_sticker_count` on `(user_id, collection_id, sticker_id, count)` for filtering by count

**RLS Policies:**

- Users can only access their own sticker inventory

**Notes:**

- Trade intent is derived from `count` values (missing = 0, duplicates > 1).
- Legacy `wanted` flag removed in v1.4.0.

---

## Album Pages System (v1.3.0)

### `collection_pages`

Defines pages within an album (team rosters, special cards sections).

```sql
CREATE TABLE collection_pages (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER NOT NULL REFERENCES collections(id) ON DELETE CASCADE,
  kind TEXT NOT NULL CHECK (kind IN ('team', 'special')),
  team_id INTEGER REFERENCES collection_teams(id) ON DELETE SET NULL,
  title TEXT NOT NULL,
  order_index INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT collection_pages_kind_team_check
    CHECK ((kind = 'team' AND team_id IS NOT NULL) OR
           (kind = 'special' AND team_id IS NULL))
);
```

**Design:**

- `kind = 'team'`: Team roster page (20 slots: badge, manager, 18 players)
- `kind = 'special'`: Special cards page (variable slots)
- `order_index`: Sort order for page navigation

**Indexes:**

- Primary key on `id`
- `idx_collection_pages_order` on `(collection_id, order_index)`
- `idx_collection_pages_page_collection` on `(page_id, collection_id)` for page validation _(v1.4.0)_
- `idx_collection_pages_collection` on `(collection_id)` for collection lookups _(v1.4.0)_

**RLS Policies:**

- Public read access
- No client writes allowed

---

### `page_slots`

Maps stickers to specific positions on album pages.

```sql
CREATE TABLE page_slots (
  page_id BIGINT NOT NULL REFERENCES collection_pages(id) ON DELETE CASCADE,
  slot_index INTEGER NOT NULL,
  sticker_id INTEGER REFERENCES stickers(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  PRIMARY KEY (page_id, slot_index)
);
```

**Design:**

- `slot_index`: 0-based position on page
- For team pages: 0 = badge, 1 = manager, 2-19 = players
- For special pages: variable based on content

**Indexes:**

- Primary key on `(page_id, slot_index)`
- `idx_page_slots_page_slot` on `(page_id, slot_index)` (covering index)
- `idx_page_slots_page_id` on `(page_id)` for page→stickers lookups
- `idx_page_slots_page_sticker` on `(page_id, sticker_id)` composite for joins

**RLS Policies:**

- Public read access
- No client writes allowed

---

## Trading System

### `trade_proposals`

Trade proposals between users.

```sql
CREATE TABLE trade_proposals (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER NOT NULL REFERENCES collections(id) ON DELETE CASCADE,
  from_user UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  to_user UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'accepted', 'rejected', 'cancelled')),
  message TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Status Flow:**

- `pending`: Awaiting recipient response
- `accepted`: Recipient accepted the trade
- `rejected`: Recipient rejected the trade
- `cancelled`: Sender cancelled before response

**Indexes:**

- Primary key on `id`
- `idx_trade_proposals_from_user` on `(from_user, status)`
- `idx_trade_proposals_to_user` on `(to_user, status)`
- `idx_trade_proposals_status` on `(status)`

**RLS Policies:**

- Users can only see proposals where they are sender or receiver
- No direct INSERT/UPDATE/DELETE (must use RPC functions)

---

### `trade_proposal_items`

Individual stickers in each proposal (offer or request).

```sql
CREATE TABLE trade_proposal_items (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  proposal_id BIGINT NOT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  sticker_id INTEGER NOT NULL REFERENCES stickers(id) ON DELETE CASCADE,
  count INTEGER NOT NULL CHECK (count > 0),
  direction TEXT NOT NULL CHECK (direction IN ('offer', 'request')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Design:**

- `direction = 'offer'`: Stickers the sender is offering
- `direction = 'request'`: Stickers the sender is requesting

**Indexes:**

- Primary key on `id`
- `idx_trade_proposal_items_proposal` on `(proposal_id)`

**RLS Policies:**

- Access controlled through parent `trade_proposals` table

---

### `trade_chats`

Chat messages within trade proposals.

```sql
CREATE TABLE trade_chats (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  trade_id BIGINT NOT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  sender_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  message TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Indexes:**

- Primary key on `id`
- `idx_trade_chats_trade_created_at` on `(trade_id, created_at)` for chronological loading

**RLS Policies:**

- Only proposal participants can read/write messages
- Messages are immutable once created

---

### `trade_reads` ✅ **v1.4.2 NEW**

Tracks last read timestamp for each user per trade (for unread message badges).

```sql
CREATE TABLE trade_reads (
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  trade_id BIGINT NOT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  last_read_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  PRIMARY KEY (user_id, trade_id)
);
```

**Design:**

- `user_id`: User who read the trade
- `trade_id`: Trade proposal ID
- `last_read_at`: Timestamp of last read action

**Indexes:**

- Primary key on `(user_id, trade_id)`
- `idx_trade_reads_user_id` on `(user_id)` for user lookups
- `idx_trade_reads_trade_id` on `(trade_id)` for trade lookups

**RLS Policies:**

- Owner-only access: `user_id = auth.uid()` for SELECT, INSERT, UPDATE, DELETE
- Users can only read/modify their own read timestamps

**Usage:**

- Upserted via `mark_trade_read(p_trade_id)` RPC when user opens chat
- Queried via `get_unread_counts(p_box, p_trade_ids)` RPC for badge counts

---

### `trades_history`

Terminal state tracking for completed/cancelled trades.

```sql
CREATE TABLE trades_history (
  trade_id BIGINT PRIMARY KEY REFERENCES trade_proposals(id) ON DELETE CASCADE,
  status TEXT NOT NULL CHECK (status IN ('completed', 'cancelled')),
  completed_at TIMESTAMPTZ,
  cancelled_at TIMESTAMPTZ,
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb
);
```

**Design:**

- Single row per trade once it reaches terminal state
- `metadata`: Reserved for audit trails, ratings, etc.

**Indexes:**

- Primary key on `trade_id`

**RLS Policies:**

- Only proposal participants can read history

---

### `trade_finalizations` _(v1.4.4)_

Two-step handshake for trade completion.

```sql
CREATE TABLE trade_finalizations (
  trade_id BIGINT NOT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  finalized_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  PRIMARY KEY (trade_id, user_id)
);
```

**Design:**

- Composite PK ensures each user can only finalize once per trade
- Both participants must finalize before trade moves to `trades_history`
- `finalized_at`: Timestamp when user confirmed finalization

**Indexes:**

- Primary key on `(trade_id, user_id)`
- `idx_trade_finalizations_trade_id` on `(trade_id)` for counting participants

**RLS Policies:**

- Only proposal participants can read finalization status
- Users can only insert their own finalization records
- No updates or deletes allowed (immutable once created)

**Usage:**

- Insert via `mark_trade_finalized(p_trade_id)` RPC
- RPC returns `both_finalized` boolean
- When both finalized, trade automatically moves to `trades_history` with status 'completed'

---

### `notifications` _(v1.4.4)_

User notifications for chat messages, proposal status changes, and finalization requests.

```sql
CREATE TABLE notifications (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  kind TEXT NOT NULL CHECK (kind IN ('chat_unread', 'proposal_accepted', 'proposal_rejected', 'finalization_requested')),
  trade_id BIGINT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  read_at TIMESTAMPTZ NULL,
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb
);
```

**Design:**

- `kind`: Notification type (4 types for MVP)
  - `chat_unread`: Unread chat messages (coalesced per trade)
  - `proposal_accepted`: Proposal was accepted
  - `proposal_rejected`: Proposal was rejected
  - `finalization_requested`: Counterparty requested finalization
- `trade_id`: Associated trade (NULL for system notifications)
- `read_at`: NULL for unread, timestamp when marked read
- `metadata`: JSON blob for additional data (e.g., last_message_id, requester_id)

**Indexes:**

- Primary key on `id`
- `idx_notifications_user_read` on `(user_id, read_at)` for unread queries
- `idx_notifications_user_kind_read` on `(user_id, kind, read_at)` for filtering by type
- `idx_notifications_user_trade_kind_read` on `(user_id, trade_id, kind, read_at)` for trade-specific queries
- `idx_notifications_trade_id` on `(trade_id)` for trade lookups
- `idx_notifications_user_trade_kind_unread_unique` (UNIQUE partial index) on `(user_id, trade_id, kind)` WHERE `kind = 'chat_unread' AND read_at IS NULL` for chat notification coalescing

**RLS Policies:**

- Users can only see their own notifications (`user_id = auth.uid()`)
- Users can only insert their own notifications (for RPC/trigger usage)
- Users can only update/delete their own notifications

**Triggers:**

- `trigger_notify_chat_message`: Creates/updates `chat_unread` notification when new chat message is inserted
- `trigger_notify_proposal_status_change`: Creates notification when proposal status changes to `accepted` or `rejected`
- `trigger_notify_finalization_requested`: Creates notification when counterparty marks trade as finalized

**Usage:**

- Query via `get_notifications()` RPC (returns enriched data with trade details)
- Count via `get_notification_count()` RPC (returns unread count)
- Mark all read via `mark_all_notifications_read()` RPC

---

## Admin & Audit (v1.5.0)

### `audit_log`

Append-only audit log of admin actions.

```sql
CREATE TABLE audit_log (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  entity TEXT NOT NULL, -- 'collection' | 'page' | 'sticker'
  entity_id BIGINT,
  action TEXT NOT NULL, -- 'create' | 'update' | 'delete' | 'bulk_upload'
  before_json JSONB,
  after_json JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Design:**

- **Append-only**: No updates or deletes allowed (enforced via RLS)
- **Entity tracking**: Records which table and record ID was affected
- **Action types**: create, update, delete, bulk_upload
- **Snapshot storage**: `before_json` and `after_json` store full record state
- **Admin only**: Populated by SECURITY DEFINER admin RPCs

**Indexes:**

- Primary key on `id`
- `idx_audit_log_user_id` on `(user_id)` for user-specific queries
- `idx_audit_log_entity` on `(entity, entity_id)` for entity-specific history
- `idx_audit_log_created_at` on `(created_at DESC)` for time-based queries

**RLS Policies:**

- Admins can read all audit entries
- Non-admins cannot access audit_log
- No UPDATE or DELETE allowed (append-only)

**Usage:**

- Populated automatically by admin RPCs on create/update/delete operations
- Used for compliance, debugging, and administrative oversight

---

## Location Matching (v1.5.0)

### `postal_codes`

Centroid data for location-based trade matching.

```sql
CREATE TABLE postal_codes (
  country CHAR(2) NOT NULL DEFAULT 'ES',
  postcode VARCHAR(10) NOT NULL,
  lat DOUBLE PRECISION NOT NULL,
  lon DOUBLE PRECISION NOT NULL,
  PRIMARY KEY (country, postcode)
);

CREATE INDEX idx_postal_codes_postcode ON postal_codes(postcode);
```

**Design:**

- **Centroid approach**: Stores lat/lon for postcode center (not exact addresses)
- **Privacy-preserving**: Distance calculated from postcode centroids
- **Country support**: Initially Spanish postcodes (ES), extensible to other countries
- **Indexed**: Fast lookups for distance calculations

**Usage:**

- Populated via admin import (CSV/XLSX of postcode centroids)
- Used by `find_mutual_traders` RPC to calculate Haversine distance
- Distance shown in UI (~12 km) without revealing exact locations

**Haversine Formula:**

```sql
-- Distance in kilometers between two lat/lon points
CREATE OR REPLACE FUNCTION haversine_distance(
  lat1 DOUBLE PRECISION,
  lon1 DOUBLE PRECISION,
  lat2 DOUBLE PRECISION,
  lon2 DOUBLE PRECISION
) RETURNS DOUBLE PRECISION AS $$
DECLARE
  earth_radius CONSTANT DOUBLE PRECISION := 6371; -- km
  dlat DOUBLE PRECISION;
  dlon DOUBLE PRECISION;
  a DOUBLE PRECISION;
  c DOUBLE PRECISION;
BEGIN
  dlat := RADIANS(lat2 - lat1);
  dlon := RADIANS(lon2 - lon1);
  a := SIN(dlat/2)^2 + COS(RADIANS(lat1)) * COS(RADIANS(lat2)) * SIN(dlon/2)^2;
  c := 2 * ATAN2(SQRT(a), SQRT(1-a));
  RETURN earth_radius * c;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

---

## Badges & Achievements (v1.3.0)

### `user_badges`

User achievement badges.

```sql
CREATE TABLE user_badges (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  badge_code TEXT NOT NULL,
  awarded_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT user_badges_user_code_unique UNIQUE (user_id, badge_code)
);
```

**Design:**

- Service-managed (no direct client writes)
- `badge_code`: Unique identifier for badge type

**Indexes:**

- Primary key on `id`
- Unique constraint on `(user_id, badge_code)`

**RLS Policies:**

- Users can only read their own badges
- No client writes allowed

---

## Database Functions (RPCs)

### Collection Statistics

#### `get_user_collection_stats`

Returns completion statistics for a user's collection. Missing counts are inferred from ownership records (count = 0).

```sql
FUNCTION get_user_collection_stats(
  p_user_id UUID,
  p_collection_id INTEGER
) RETURNS JSON
```

**Returns:**

```json
{
  "total_stickers": 600,
  "owned_stickers": 450,
  "completion_percentage": 75,
  "duplicates": 120,
  "missing": 150,
}
```

**Security:** SECURITY DEFINER

---

#### `get_completion_report` _(v1.3.0)_

Generates per-page completion report.

```sql
FUNCTION get_completion_report(
  p_user_id UUID,
  p_collection_id INTEGER
) RETURNS JSON
```

**Returns:**

```json
{
  "collection_id": 1,
  "pages": [
    {
      "page_id": 1,
      "title": "FC Barcelona",
      "kind": "team",
      "order_index": 1,
      "missing": [1, 5, 12],
      "repes": [3, 7, 15]
    }
  ]
}
```

**Security:** SECURITY DEFINER, requires caller = `p_user_id`

---

### Sticker Management

#### `bulk_add_stickers_by_numbers` _(v1.3.0)_

Add multiple stickers by their numbers in one operation.

```sql
FUNCTION bulk_add_stickers_by_numbers(
  p_user_id UUID,
  p_collection_id INTEGER,
  p_numbers INTEGER[]
) RETURNS JSON
```

**Returns:**

```json
{
  "added": 5,
  "duplicates": [12, 15],
  "invalid": [999]
}
```

**Security:** SECURITY DEFINER, requires caller = `p_user_id`

---

#### `search_stickers` _(v1.3.0)_

Search stickers with filters and ownership status.

```sql
FUNCTION search_stickers(
  p_collection_id INTEGER,
  p_query TEXT,
  p_filters JSONB
) RETURNS SETOF sticker_search_result
```

**Filters:**

```json
{
  "owned": true,
  "missing": false,
  "repes": true,
  "kind": "team"
}
```

**Security:** SECURITY DEFINER, authenticated users only

---

### Trading - Discovery

#### `find_mutual_traders` (Enhanced v1.5.0)

Find users with mutual trading opportunities. Sticker intent is inferred from inventory counts: a sticker is missing when the seeker has `count = 0`, and a tradeable duplicate is available when the owner has `count > 1`.

**v1.5.0 Enhancement**: Added location-based scoring with Haversine distance calculation.

```sql
FUNCTION find_mutual_traders(
  p_user_id UUID,
  p_collection_id INTEGER,
  p_rarity TEXT DEFAULT NULL,
  p_team TEXT DEFAULT NULL,
  p_query TEXT DEFAULT NULL,
  p_min_overlap INTEGER DEFAULT 1,
  p_limit INTEGER DEFAULT 20,
  p_offset INTEGER DEFAULT 0,
  -- v1.5.0: Location-based parameters
  p_lat DOUBLE PRECISION DEFAULT NULL,
  p_lon DOUBLE PRECISION DEFAULT NULL,
  p_radius_km INTEGER DEFAULT NULL,
  p_sort TEXT DEFAULT 'mixed' -- 'distance' | 'overlap' | 'mixed'
) RETURNS TABLE (
  match_user_id UUID,
  nickname TEXT,
  postcode TEXT, -- v1.5.0: For distance display (optional)
  overlap_from_them_to_me BIGINT,
  overlap_from_me_to_them BIGINT,
  total_mutual_overlap BIGINT,
  distance_km DOUBLE PRECISION, -- v1.5.0: NULL if no location data
  score DOUBLE PRECISION -- v1.5.0: Mixed score (0.6 * normalized_overlap + 0.4 * distance_decay)
)
```

**v1.5.0 Location Parameters:**

- `p_lat`, `p_lon`: User's location from postcode centroid (from `postal_codes` table)
- `p_radius_km`: Filter matches within radius (e.g., 10, 25, 50, 100 km)
- `p_sort`: Sort mode
  - `'overlap'`: Traditional sort by overlap count (DESC)
  - `'distance'`: Sort by distance (ASC, closest first)
  - `'mixed'`: Weighted score = 0.6 × (overlap / max_overlap) + 0.4 × (1 - distance / max_distance)

**Mixed Scoring Algorithm:**

```sql
-- Normalize overlap to 0-1 range
normalized_overlap := overlap / NULLIF(MAX(overlap) OVER (), 0)

-- Normalize distance with decay (closer = higher score)
distance_decay := 1 - (distance_km / NULLIF(MAX(distance_km) OVER (), 0))

-- Final score (60% overlap weight, 40% proximity weight)
score := 0.6 * normalized_overlap + 0.4 * distance_decay
```

**Privacy Note:** Only postcode is stored (not exact address). Distance calculated from centroid.

**Security:** SECURITY DEFINER

---

#### `get_mutual_trade_detail`

Get detailed sticker lists for a trading pair. Rows are emitted with `direction = 'they_offer'` when the other user has duplicates (`count > 1`) and the current user has none (`count = 0`), and `direction = 'i_offer'` for the inverse.

```sql
FUNCTION get_mutual_trade_detail(
  p_user_id UUID,
  p_other_user_id UUID,
  p_collection_id INTEGER
) RETURNS TABLE (
  direction TEXT,
  sticker_id INTEGER,
  sticker_code TEXT,
  player_name TEXT,
  team_name TEXT,
  rarity TEXT,
  count INTEGER
)
```

**Security:** SECURITY DEFINER

---

### Trading - Proposals

#### `create_trade_proposal`

Create a new trade proposal. The message is stored as the first chat message, not in the proposal record.

```sql
FUNCTION create_trade_proposal(
  p_collection_id INTEGER,
  p_to_user UUID,
  p_offer_items proposal_item[],
  p_request_items proposal_item[],
  p_message TEXT
) RETURNS BIGINT
```

**Parameters:**
- `p_collection_id`: The collection ID for the trade
- `p_to_user`: UUID of the user receiving the proposal
- `p_offer_items`: Array of items the sender is offering
- `p_request_items`: Array of items the sender is requesting
- `p_message`: Optional message (stored as first chat message if provided)

**Returns:** The proposal ID (BIGINT)

**Behavior:**
- Creates a trade proposal with status 'pending'
- Inserts offer and request items into trade_proposal_items
- If a message is provided, inserts it as the first message in trade_chats
- The proposal.message field is always NULL (messages go to trade_chats)

**Security:** SECURITY DEFINER

---

#### `respond_to_trade_proposal`

Accept, reject, or cancel a proposal.

```sql
FUNCTION respond_to_trade_proposal(
  p_proposal_id INTEGER,
  p_action TEXT
) RETURNS JSON
```

**Actions:** `'accept'`, `'reject'`, `'cancel'`

**Security:** SECURITY DEFINER

---

#### `list_trade_proposals`

List inbox or outbox proposals.

```sql
FUNCTION list_trade_proposals(
  p_user_id UUID,
  p_box TEXT,
  p_limit INTEGER DEFAULT 20,
  p_offset INTEGER DEFAULT 0
) RETURNS TABLE (...)
```

**Box:** `'inbox'` or `'outbox'`

**Security:** SECURITY DEFINER

---

#### `get_trade_proposal_detail`

Get complete proposal details.

```sql
FUNCTION get_trade_proposal_detail(
  p_proposal_id INTEGER
) RETURNS JSON
```

**Security:** SECURITY DEFINER

---

### Trading - History

#### `complete_trade` _(v1.3.0)_

Mark a trade as completed.

```sql
FUNCTION complete_trade(
  p_trade_id BIGINT
) RETURNS VOID
```

**Security:** SECURITY DEFINER, only participants

---

#### `cancel_trade` _(v1.3.0)_

Cancel a trade.

```sql
FUNCTION cancel_trade(
  p_trade_id BIGINT
) RETURNS VOID
```

**Security:** SECURITY DEFINER, only participants

---

### Trading - Chat & Unread Badges ✅ **v1.4.2 NEW**

#### `mark_trade_read`

Mark a trade as read for the current user (upserts last_read_at timestamp).

```sql
FUNCTION mark_trade_read(
  p_trade_id BIGINT
) RETURNS VOID
```

**Parameters:**

- `p_trade_id`: Trade proposal ID (required)

**Behavior:**

- Automatically uses `auth.uid()` for user_id (SECURITY DEFINER)
- Upserts `trade_reads` row with `last_read_at = NOW()`
- Validates user is a participant in the trade
- Raises exception if not authenticated or not a participant

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { error } = await supabase.rpc('mark_trade_read', {
  p_trade_id: tradeId,
});

if (error) {
  console.error('Error marking trade as read:', error);
}
```

---

#### `get_unread_counts`

Returns unread message counts per trade for the current user in the specified box.

```sql
FUNCTION get_unread_counts(
  p_box TEXT,
  p_trade_ids INT8[] DEFAULT NULL
) RETURNS TABLE (
  trade_id BIGINT,
  unread_count BIGINT
)
```

**Parameters:**

- `p_box`: Box to query (`'inbox'` or `'outbox'`) (required)
- `p_trade_ids`: Optional array of trade IDs to filter by (for pagination)

**Returns:**

Array of objects with:
- `trade_id`: Trade proposal ID
- `unread_count`: Number of unread messages from counterparty

**Behavior:**

- Automatically scopes to `auth.uid()` (SECURITY DEFINER)
- Filters trades by box:
  - `inbox`: trades where `to_user = auth.uid()`
  - `outbox`: trades where `from_user = auth.uid()`
- Counts messages from counterparty (`sender_id <> auth.uid()`) where `created_at > COALESCE(last_read_at, 'epoch')`
- Returns 0 for trades with no unread messages
- If `p_trade_ids` provided, only returns counts for those trades

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { data, error } = await supabase.rpc('get_unread_counts', {
  p_box: 'inbox',
  p_trade_ids: [123, 456, 789], // Optional
});

if (error) throw error;

// data = [{ trade_id: 123, unread_count: 5 }, { trade_id: 456, unread_count: 0 }, ...]
const unreadMap = new Map(data.map(item => [item.trade_id, item.unread_count]));
```

---

### Sticker Completion

#### `mark_team_page_complete` _(v1.4.0)_

Marks all stickers on a team page as owned (count=1) for a user. Only adds stickers that are currently missing (no row or count=0). Idempotent - returns added_count=0 if page already complete.

```sql
FUNCTION mark_team_page_complete(
  p_user_id UUID,
  p_collection_id INT,
  p_page_id INT
) RETURNS JSONB
```

**Parameters:**

- `p_user_id`: User UUID (must match authenticated user)
- `p_collection_id`: Collection ID that owns the page
- `p_page_id`: Page ID to mark complete (must be a team page)

**Returns:**

```json
{
  "added_count": 5,
  "affected_sticker_ids": [1, 5, 12, 18, 20]
}
```

**Preconditions:**

- User must be authenticated (`auth.uid()`)
- Caller must be acting on their own behalf (`p_user_id = auth.uid()`)
- Page must belong to the specified collection
- Page must be a team page (`kind = 'team'` or exactly 20 slots)

**Side Effects:**

- Inserts new rows into `user_stickers` with `count = 1` for missing stickers
- Updates existing rows where `count = 0` to `count = 1`
- Does NOT modify stickers with `count >= 1` (preserves singles and duplicates)
- Idempotent: re-running on same page returns `added_count = 0`

**Security:**

- `SECURITY DEFINER`: Runs with elevated privileges
- Auth guard: Validates `p_user_id = auth.uid()` at function start
- RLS remains enabled on `user_stickers` table
- Cross-user writes blocked by exception

**Scope:**

- **Team pages only**: Badge + manager + 18 players (20 slots)
- **Special pages**: Not supported in Phase 1 (raises exception)

**Error Cases:**

- Cross-user write: `Unauthorized: Cannot modify stickers for another user`
- Invalid page/collection: `Invalid page_id X for collection_id Y`
- Non-team page: `Only team pages are supported` (SQLSTATE `check_violation`)
- RLS violations: Standard Supabase RLS errors

**Full Implementation:**

```sql
-- Drop existing function if it exists
DROP FUNCTION IF EXISTS mark_team_page_complete(UUID, INT, INT);

-- Create the function with team page validation
CREATE OR REPLACE FUNCTION mark_team_page_complete(
    p_user_id UUID,
    p_collection_id INT,
    p_page_id INT
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO public
AS $$
DECLARE
    v_added_count INT := 0;
    v_affected_sticker_ids INT[] := ARRAY[]::INT[];
    v_page_exists BOOLEAN;
    v_page_kind TEXT;
    v_slot_count INT;
BEGIN
    -- Security: Verify the caller is acting on their own behalf
    IF p_user_id <> auth.uid() THEN
        RAISE EXCEPTION 'Unauthorized: Cannot modify stickers for another user';
    END IF;

    -- Validate that the page belongs to the collection and get page kind
    SELECT
        EXISTS(
            SELECT 1
            FROM collection_pages
            WHERE id = p_page_id
              AND collection_id = p_collection_id
        ),
        (SELECT kind FROM collection_pages WHERE id = p_page_id)
    INTO v_page_exists, v_page_kind;

    IF NOT v_page_exists THEN
        RAISE EXCEPTION 'Invalid page_id % for collection_id %', p_page_id, p_collection_id;
    END IF;

    -- Guard: Only allow team pages
    -- First try to use collection_pages.kind if available
    IF v_page_kind IS NOT NULL THEN
        -- Column exists, use it directly
        IF v_page_kind <> 'team' THEN
            RAISE EXCEPTION 'Only team pages are supported'
                USING ERRCODE = 'check_violation';
        END IF;
    ELSE
        -- Fallback: check slot count (team pages have exactly 20 slots)
        SELECT COUNT(*)
        INTO v_slot_count
        FROM page_slots
        WHERE page_id = p_page_id;

        IF v_slot_count <> 20 THEN
            RAISE EXCEPTION 'Only team pages are supported'
                USING ERRCODE = 'check_violation';
        END IF;
    END IF;

    -- Insert missing stickers (count = 0 or no row) and collect affected IDs
    WITH page_stickers AS (
        -- Get all stickers on this page that belong to the collection
        SELECT ps.sticker_id
        FROM page_slots ps
        INNER JOIN stickers s ON s.id = ps.sticker_id
        WHERE ps.page_id = p_page_id
          AND s.collection_id = p_collection_id
    ),
    missing_stickers AS (
        -- Find stickers that are missing (no row or count = 0)
        SELECT ps.sticker_id
        FROM page_stickers ps
        LEFT JOIN user_stickers us ON
            us.user_id = p_user_id
            AND us.sticker_id = ps.sticker_id
        WHERE us.sticker_id IS NULL OR us.count = 0
    ),
    inserted AS (
        -- Upsert: insert new rows or update count to 1 where it was 0
        INSERT INTO user_stickers (user_id, sticker_id, count)
        SELECT p_user_id, sticker_id, 1
        FROM missing_stickers
        ON CONFLICT (user_id, sticker_id)
        DO UPDATE SET count = 1
        WHERE user_stickers.count = 0
        RETURNING sticker_id
    )
    SELECT
        COUNT(*)::INT,
        ARRAY_AGG(sticker_id ORDER BY sticker_id)
    INTO v_added_count, v_affected_sticker_ids
    FROM inserted;

    -- Handle case where no stickers were added
    IF v_affected_sticker_ids IS NULL THEN
        v_affected_sticker_ids := ARRAY[]::INT[];
    END IF;

    RETURN jsonb_build_object(
        'added_count', v_added_count,
        'affected_sticker_ids', v_affected_sticker_ids
    );
END;
$$;

-- Revoke all permissions from public
REVOKE ALL ON FUNCTION mark_team_page_complete(UUID, INT, INT) FROM PUBLIC;

-- Grant execute to authenticated users
GRANT EXECUTE ON FUNCTION mark_team_page_complete(UUID, INT, INT) TO authenticated;

-- Add function comment
COMMENT ON FUNCTION mark_team_page_complete(UUID, INT, INT) IS
'Marks all stickers on a team page as owned (count=1) for a user. Only adds stickers that are currently missing (no row or count=0). Idempotent - returns added_count=0 if page already complete. Only supports team pages (kind=team or exactly 20 slots).';
```

---

## Admin RPCs (v1.5.0)

### Collections Management

#### `admin_upsert_collection`

Create or update a collection (admin only).

```sql
FUNCTION admin_upsert_collection(
  p_collection JSONB
) RETURNS JSONB
```

**Parameters:**
- `p_collection`: JSON object with collection fields (id optional for create)
  - `id` (optional): Collection ID for update
  - `name`: Collection name
  - `competition`: Competition name
  - `year`: Year
  - `description`: Description
  - `image_url`: Cover image URL
  - `is_active`: Active status (defaults to true)

**Returns:**
```json
{
  "id": 123,
  "name": "LaLiga 2025-26",
  "created": true
}
```

**Security:** SECURITY DEFINER, requires `is_admin = TRUE` in JWT claims

---

#### `admin_delete_collection`

Delete a collection (admin only).

```sql
FUNCTION admin_delete_collection(
  p_collection_id BIGINT
) RETURNS VOID
```

**Security:** SECURITY DEFINER, requires admin, cascades to pages/stickers/user data

---

### Pages Management

#### `admin_upsert_page`

Create or update a collection page.

```sql
FUNCTION admin_upsert_page(
  p_page JSONB
) RETURNS JSONB
```

**Parameters:**
- `p_page`: JSON object with page fields
  - `id` (optional): Page ID for update
  - `collection_id`: Parent collection
  - `kind`: 'team' or 'special'
  - `team_id`: Team ID (required if kind='team')
  - `title`: Page title
  - `order_index`: Sort order

**Returns:**
```json
{
  "id": 456,
  "title": "FC Barcelona",
  "created": false
}
```

**Security:** SECURITY DEFINER, requires admin

---

#### `admin_delete_page`

Delete a page and its slots.

```sql
FUNCTION admin_delete_page(
  p_page_id BIGINT
) RETURNS VOID
```

**Security:** SECURITY DEFINER, requires admin, cascades to page_slots

---

### Stickers Management

#### `admin_upsert_sticker`

Create or update a sticker.

```sql
FUNCTION admin_upsert_sticker(
  p_sticker JSONB
) RETURNS JSONB
```

**Parameters:**
- `p_sticker`: JSON object with sticker fields
  - `id` (optional): Sticker ID for update
  - `collection_id`: Parent collection
  - `team_id`: Team ID (optional)
  - `code`: Sticker code
  - `player_name`: Player name
  - `position`: Position (optional)
  - `nationality`: Nationality (optional)
  - `rating`: Rating (optional)
  - `rarity`: Rarity ('common', 'rare', 'epic', 'legendary')
  - `image_url`: External image URL (optional)
  - `sticker_number`: Sequential number (optional for now)
  - `image_path_webp_300`: Storage path for 300px WebP (optional)
  - `thumb_path_webp_100`: Storage path for 100px thumb (optional)

**Returns:**
```json
{
  "id": 789,
  "code": "BAR001",
  "player_name": "Lionel Messi",
  "created": true
}
```

**Security:** SECURITY DEFINER, requires admin

---

#### `admin_delete_sticker`

Delete a sticker.

```sql
FUNCTION admin_delete_sticker(
  p_sticker_id BIGINT
) RETURNS VOID
```

**Security:** SECURITY DEFINER, requires admin, cascades to user_stickers/page_slots

---

### Bulk Upload

#### `admin_bulk_upload_preview`

Preview bulk upload changes without applying them.

```sql
FUNCTION admin_bulk_upload_preview(
  p_upload_data JSONB
) RETURNS JSONB
```

**Parameters:**
- `p_upload_data`: JSON array of stickers/pages/collections with validation rules

**Returns:**
```json
{
  "valid_rows": 50,
  "invalid_rows": 2,
  "errors": [
    {"row": 12, "error": "Missing required field: player_name"},
    {"row": 25, "error": "Duplicate sticker code: BAR001"}
  ],
  "warnings": [
    {"row": 5, "warning": "sticker_number is optional but recommended"}
  ],
  "diffs": [
    {"action": "create", "entity": "sticker", "data": {...}},
    {"action": "update", "entity": "sticker", "id": 123, "changes": {...}}
  ]
}
```

**Security:** SECURITY DEFINER, requires admin, read-only (no writes)

---

#### `admin_bulk_upload_apply`

Apply bulk upload changes after preview approval.

```sql
FUNCTION admin_bulk_upload_apply(
  p_upload_data JSONB
) RETURNS JSONB
```

**Parameters:**
- `p_upload_data`: Same structure as preview

**Returns:**
```json
{
  "created": 45,
  "updated": 5,
  "failed": 0,
  "audit_log_entries": 50
}
```

**Behavior:**
- Transactional: all or nothing
- Populates audit_log for each operation
- Uploads images to Supabase Storage (WebP conversion + thumbnails)
- Returns summary of operations

**Security:** SECURITY DEFINER, requires admin

---

**Image Upload Note:**
Admin bulk upload automatically:
1. Accepts uploaded images (PNG/JPG/WebP)
2. Converts to WebP format
3. Generates 300px full-size and 100px thumbnail
4. Uploads to `sticker-images/{collection_id}/` and `sticker-images/{collection_id}/thumbs/`
5. Populates `image_path_webp_300` and `thumb_path_webp_100` in stickers table

---

## Triggers

### `handle_updated_at`

Automatically updates `updated_at` column on row modifications.

Applied to:

- `profiles`
- `user_stickers`
- `trade_proposals`

---

## Supabase Storage Buckets

### `sticker-images`

Stores sticker artwork.

**Structure:**

```
sticker-images/
├── {collection_id}/
│   ├── {sticker_number}-{sticker_id}.webp (300px)
│   └── thumbs/
│       └── {sticker_number}-{sticker_id}.webp (100px)
```

**Configuration:**

- Public read access
- Authenticated write only
- Max file size: 5MB
- Allowed MIME types: `image/webp`, `image/png`, `image/jpeg`

---

### `avatars`

Stores user profile avatars.

**Configuration:**

- Public read access
- Authenticated write only
- Max file size: 2MB
- Allowed MIME types: `image/webp`, `image/png`, `image/jpeg`

---

## Migration Notes

### Deployment Checklist

1. ✅ All core tables created
2. ✅ All indexes applied
3. ✅ All RLS policies active
4. ✅ All RPC functions deployed
5. ✅ Storage buckets configured
6. ⚠️ Backfill `stickers.sticker_number` before enforcing NOT NULL
7. ⚠️ Populate `collection_pages` and `page_slots` for active collections

### Performance Monitoring

Key indexes for monitoring:

- `idx_user_stickers_trading_v2` (Phase 1 high traffic)
- `idx_user_stickers_trading` (kept during transition)
- `idx_stickers_collection_filters` (trading queries)
- `idx_trade_proposals_to_user` (inbox queries)
- `idx_collection_pages_order` (album navigation)
- `idx_page_slots_page_id` (page completion queries - v1.4.0)
- `idx_user_stickers_user_collection_sticker_count` (page completion queries - v1.4.0)

---

## Performance Indexes (v1.4.0)

The following indexes optimize the `mark_team_page_complete` function and related page-based operations:

```sql
-- Indexes for mark_team_page_complete performance
-- These support fast lookups in the function's CTEs

-- Index for page_slots: quick lookup of all stickers on a given page
CREATE INDEX IF NOT EXISTS idx_page_slots_page_id
ON page_slots(page_id);

-- Composite index for page_slots: covers both columns used in joins
CREATE INDEX IF NOT EXISTS idx_page_slots_page_sticker
ON page_slots(page_id, sticker_id);

-- Index for user_stickers: fast lookup by user + collection + sticker
-- This supports the LEFT JOIN in missing_stickers CTE
CREATE INDEX IF NOT EXISTS idx_user_stickers_user_collection_sticker
ON user_stickers(user_id, collection_id, sticker_id);

-- Additional index including count for filtering count = 0
CREATE INDEX IF NOT EXISTS idx_user_stickers_user_collection_sticker_count
ON user_stickers(user_id, collection_id, sticker_id, count);

-- Index for collection_pages: validate page belongs to collection
CREATE INDEX IF NOT EXISTS idx_collection_pages_page_collection
ON collection_pages(page_id, collection_id);

-- Alternative index if collection_pages has 'id' as primary key
CREATE INDEX IF NOT EXISTS idx_collection_pages_collection
ON collection_pages(collection_id);

/*
EXPECTED QUERY PLAN SHAPE:
============================

1. Page validation (collection_pages):
   -> Index Scan using idx_collection_pages_page_collection
   -> Should be instant lookup

2. page_stickers CTE (page_slots):
   -> Index Scan using idx_page_slots_page_id
   -> Returns ~20 rows for team pages

3. missing_stickers CTE (LEFT JOIN):
   -> Nested Loop Left Join
      -> Seq Scan on page_stickers (small CTE, ~20 rows)
      -> Index Scan using idx_user_stickers_user_collection_sticker
   -> Filter on (us.sticker_id IS NULL OR us.count = 0)

4. INSERT with ON CONFLICT:
   -> Uses unique constraint on (user_id, collection_id, sticker_id)
   -> Supported by idx_user_stickers_user_collection_sticker

Overall: Should be < 10ms for typical team page (20 stickers)
Key: All joins use index scans, no table scans except tiny CTEs
*/
```

---

### Trade Finalization _(v1.4.4)_

#### `mark_trade_finalized`

Two-step handshake for trade completion. Both participants must call this function before the trade is marked as completed.

```sql
FUNCTION mark_trade_finalized(
  p_trade_id BIGINT
) RETURNS JSONB
```

**Parameters:**

- `p_trade_id`: Trade proposal ID (required)

**Returns:**

```json
{
  "both_finalized": true,
  "finalized_count": 2
}
```

**Behavior:**

- Automatically uses `auth.uid()` for user_id (SECURITY DEFINER)
- Validates user is a participant in the trade (from_user or to_user)
- Inserts finalization record for current user
- Checks if both participants have finalized
- If both finalized, automatically creates `trades_history` record with status 'completed'
- Idempotent - calling multiple times by same user has no effect
- Raises exception if not authenticated or not a participant

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { data, error } = await supabase.rpc('mark_trade_finalized', {
  p_trade_id: tradeId,
});

if (error) {
  console.error('Error finalizing trade:', error);
  return;
}

if (data.both_finalized) {
  toast.success('¡Intercambio finalizado! Ambos participantes confirmaron.');
  // Close modal, refresh history, etc.
} else {
  toast.success(`Confirmado. Esperando confirmación de la otra parte (${data.finalized_count}/2).`);
}
```

---

### Notifications _(v1.4.4)_

#### `get_notifications`

Returns all notifications for the current user with enriched trade details.

```sql
FUNCTION get_notifications()
RETURNS TABLE (
  id BIGINT,
  kind TEXT,
  trade_id BIGINT,
  created_at TIMESTAMPTZ,
  read_at TIMESTAMPTZ,
  metadata JSONB,
  proposal_from_user UUID,
  proposal_to_user UUID,
  proposal_status TEXT,
  from_user_nickname TEXT,
  to_user_nickname TEXT
)
```

**Returns:**

Array of notification objects with joined trade proposal and profile data:
- `id`: Notification ID
- `kind`: Notification type (chat_unread, proposal_accepted, proposal_rejected, finalization_requested)
- `trade_id`: Associated trade ID
- `created_at`: When notification was created
- `read_at`: When notification was marked read (NULL if unread)
- `metadata`: Additional JSON data
- `proposal_from_user`: UUID of proposal sender
- `proposal_to_user`: UUID of proposal recipient
- `proposal_status`: Current status of trade proposal
- `from_user_nickname`: Sender's nickname
- `to_user_nickname`: Recipient's nickname

**Behavior:**

- Automatically scopes to `auth.uid()` (SECURITY DEFINER)
- Ordered by unread first, then by creation date descending
- Includes LEFT JOIN to trade_proposals and profiles for enriched data

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { data: notifications, error } = await supabase.rpc('get_notifications');

if (error) throw error;

// data is enriched with trade and profile information
```

---

#### `get_notification_count`

Returns count of unread notifications for the current user.

```sql
FUNCTION get_notification_count()
RETURNS INTEGER
```

**Returns:**

Integer count of notifications where `read_at IS NULL`

**Behavior:**

- Automatically scopes to `auth.uid()` (SECURITY DEFINER)
- Fast count query using indexed `read_at` column

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { data: count, error } = await supabase.rpc('get_notification_count');

if (error) throw error;

// Display badge with count
setBadgeCount(count);
```

---

#### `mark_all_notifications_read`

Marks all unread notifications as read for the current user.

```sql
FUNCTION mark_all_notifications_read()
RETURNS VOID
```

**Behavior:**

- Automatically scopes to `auth.uid()` (SECURITY DEFINER)
- Updates all notifications where `read_at IS NULL` to `read_at = NOW()`
- Idempotent - safe to call multiple times

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { error } = await supabase.rpc('mark_all_notifications_read');

if (error) {
  console.error('Error marking notifications as read:', error);
  return;
}

// Refresh notification list
```

---

## Schema Version History

- **v1.5.0** (Current): Critical fixes (batch RPC, ErrorBoundary), Admin Backoffice (RBAC, audit log), Location Matching (Haversine), Badges UI, Quick Entry, Avatar Seed
- **v1.4.4**: Trade finalization handshake, notifications system (MVP)
- **v1.4.3**: Trade flow optimization, SegmentedTabs component
- **v1.4.2**: Trade composer UX improvements, trade matching logic fixes
- **v1.4.1**: Complete Retro-Comic theme rollout
- **v1.4.0**: Mark team page complete feature, schema cleanup
- **v1.3.0**: Album pages, trade history, badges, enhanced sticker images
- **v1.2.0**: Complete trade proposals system
- **v1.1.0**: Trading discovery (find mutual traders)
- **v1.0.0**: Core collection and sticker management

---

**Status:** 🚧 v1.5.0 schema documented (pre-implementation)
**Next:**
1. Critical fixes (1 day) → batch RPC, ErrorBoundary, logger
2. Implement Admin RPCs → Location matching RPC → Admin UI → Badges UI → Quick Entry → Avatar Seed
3. High priority: TanStack Query, Zod, CSRF, hook refactoring
