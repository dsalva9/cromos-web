# Database Schema Documentation

## Current State: v1.5.0 (Critical Fixes + Admin + Location Matching + Badges + Quick Entry + Avatars)

Last updated: 2025-10-10
Source: Planned schema for v1.5.0 (pre-implementation)

## Overview

The CambioCromos database consists of 17 tables supporting:

- User authentication and profiles
- **Admin role-based access control (v1.5.0)**
- **Location-based matching with Haversine distance (v1.5.0)**
- Multi-collection sticker management
- Album-style page navigation (v1.3.0)
- Complete trading proposal system
- Trade history and chat
- Trade finalization handshake (v1.4.4)
- Notifications system (v1.4.4)
- User badges and achievements
- **Admin audit log (v1.5.0)**
- **Postal codes centroid data (v1.5.0)**

---

## Core Tables

### `profiles`

User profiles extending Supabase Auth.

```sql
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  nickname TEXT,
  avatar_url TEXT,
  is_admin BOOLEAN DEFAULT FALSE, -- v1.5.0: Admin role flag
  postcode TEXT NULL, -- v1.5.0: Optional postcode for location-based matching
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**v1.5.0 Additions:**
- `is_admin`: Boolean flag for admin access. Used with JWT claims enforcement in SECURITY DEFINER RPCs.
- `postcode`: Optional postcode (e.g., "28001") for location-based trade matching. Privacy-preserving (no exact address).

**Indexes:**

- Primary key on `id`

**RLS Policies:**

- Users can read all profiles
- Users can only update their own profile
- `is_admin` column is protected: only admins can modify it (enforced via RPC + JWT claims)

---

### `collections`

Sticker collections (e.g., "UEFA Euro 2024", "Liga 2024/25").

```sql
CREATE TABLE collections (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  name TEXT NOT NULL,
  competition TEXT NOT NULL,
  year TEXT NOT NULL,
  description TEXT,
  image_url TEXT,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Indexes:**

- Primary key on `id`
- `idx_collections_active` on `(is_active)`

**RLS Policies:**

- Public read access
- Admin-only write access

---

### `collection_teams`

Teams within each collection.

```sql
CREATE TABLE collection_teams (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER REFERENCES collections(id) ON DELETE CASCADE,
  team_name TEXT NOT NULL,
  team_code TEXT,
  logo_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Indexes:**

- Primary key on `id`
- `idx_collection_teams_collection` on `(collection_id)`
- `idx_collection_teams_name` on `(team_name)` for trading queries

**RLS Policies:**

- Public read access
- Admin-only write access

---

### `stickers`

Individual stickers within collections.

```sql
CREATE TABLE stickers (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER REFERENCES collections(id) ON DELETE CASCADE,
  team_id INTEGER REFERENCES collection_teams(id) ON DELETE SET NULL,
  code TEXT NOT NULL,
  player_name TEXT NOT NULL,
  position TEXT,
  nationality TEXT,
  rating INTEGER,
  rarity TEXT CHECK (rarity IN ('common', 'rare', 'epic', 'legendary')),
  image_url TEXT,
  sticker_number INTEGER,
  image_path_webp_300 TEXT,
  thumb_path_webp_100 TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),

  CONSTRAINT unique_sticker_code UNIQUE (collection_id, code)
);
```

**New in v1.3.0:**

- `sticker_number`: Unique sequential number within collection
- `image_path_webp_300`: Path to full-size WebP image in Supabase Storage
- `thumb_path_webp_100`: Path to 100px thumbnail in Supabase Storage

**Indexes:**

- Primary key on `id`
- `idx_stickers_collection` on `(collection_id)`
- `idx_stickers_collection_filters` on `(collection_id, rarity, team_id, player_name)` for trading
- `idx_stickers_collection_number_unique` (partial) on `(collection_id, sticker_number)` WHERE `sticker_number IS NOT NULL`

**RLS Policies:**

- Public read access
- Admin-only write access

---

### `user_collections`

Tracks which collections users have joined and which is active.

```sql
CREATE TABLE user_collections (
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  collection_id INTEGER REFERENCES collections(id) ON DELETE CASCADE,
  is_active BOOLEAN DEFAULT false,
  joined_at TIMESTAMPTZ DEFAULT NOW(),

  PRIMARY KEY (user_id, collection_id),
  CONSTRAINT unique_active_per_user
    UNIQUE (user_id, is_active)
    WHERE (is_active = true)
);
```

**Constraints:**

- Only one active collection per user (partial unique constraint)

**Indexes:**

- Primary key on `(user_id, collection_id)`

**RLS Policies:**

- Users can only access their own collection memberships



---

### `user_stickers`

User's sticker inventory.

```sql
CREATE TABLE user_stickers (
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  sticker_id INTEGER REFERENCES stickers(id) ON DELETE CASCADE,
  count INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  PRIMARY KEY (user_id, sticker_id)
);
```

**Indexes:**

- Primary key on `(user_id, sticker_id)`
- `idx_user_stickers_trading_v2` on `(sticker_id, user_id, count)` for duplicate-driven trading queries
- `idx_user_stickers_user_collection_sticker` on `(user_id, collection_id, sticker_id)` for fast user inventory lookups
- `idx_user_stickers_user_collection_sticker_count` on `(user_id, collection_id, sticker_id, count)` for filtering by count

**RLS Policies:**

- Users can only access their own sticker inventory

**Notes:**

- Trade intent is derived from `count` values (missing = 0, duplicates > 1).
- Legacy `wanted` flag removed in v1.4.0.

---

## Album Pages System (v1.3.0)

### `collection_pages`

Defines pages within an album (team rosters, special cards sections).

```sql
CREATE TABLE collection_pages (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER NOT NULL REFERENCES collections(id) ON DELETE CASCADE,
  kind TEXT NOT NULL CHECK (kind IN ('team', 'special')),
  team_id INTEGER REFERENCES collection_teams(id) ON DELETE SET NULL,
  title TEXT NOT NULL,
  order_index INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT collection_pages_kind_team_check
    CHECK ((kind = 'team' AND team_id IS NOT NULL) OR
           (kind = 'special' AND team_id IS NULL))
);
```

**Design:**

- `kind = 'team'`: Team roster page (20 slots: badge, manager, 18 players)
- `kind = 'special'`: Special cards page (variable slots)
- `order_index`: Sort order for page navigation

**Indexes:**

- Primary key on `id`
- `idx_collection_pages_order` on `(collection_id, order_index)`
- `idx_collection_pages_page_collection` on `(page_id, collection_id)` for page validation _(v1.4.0)_
- `idx_collection_pages_collection` on `(collection_id)` for collection lookups _(v1.4.0)_

**RLS Policies:**

- Public read access
- No client writes allowed

---

### `page_slots`

Maps stickers to specific positions on album pages.

```sql
CREATE TABLE page_slots (
  page_id BIGINT NOT NULL REFERENCES collection_pages(id) ON DELETE CASCADE,
  slot_index INTEGER NOT NULL,
  sticker_id INTEGER REFERENCES stickers(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  PRIMARY KEY (page_id, slot_index)
);
```

**Design:**

- `slot_index`: 0-based position on page
- For team pages: 0 = badge, 1 = manager, 2-19 = players
- For special pages: variable based on content

**Indexes:**

- Primary key on `(page_id, slot_index)`
- `idx_page_slots_page_slot` on `(page_id, slot_index)` (covering index)
- `idx_page_slots_page_id` on `(page_id)` for pageâ†’stickers lookups
- `idx_page_slots_page_sticker` on `(page_id, sticker_id)` composite for joins

**RLS Policies:**

- Public read access
- No client writes allowed

---

## Trading System

### `trade_proposals`

Trade proposals between users.

```sql
CREATE TABLE trade_proposals (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER NOT NULL REFERENCES collections(id) ON DELETE CASCADE,
  from_user UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  to_user UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'accepted', 'rejected', 'cancelled')),
  message TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Status Flow:**

- `pending`: Awaiting recipient response
- `accepted`: Recipient accepted the trade
- `rejected`: Recipient rejected the trade
- `cancelled`: Sender cancelled before response

**Indexes:**

- Primary key on `id`
- `idx_trade_proposals_from_user` on `(from_user, status)`
- `idx_trade_proposals_to_user` on `(to_user, status)`
- `idx_trade_proposals_status` on `(status)`

**RLS Policies:**

- Users can only see proposals where they are sender or receiver
- No direct INSERT/UPDATE/DELETE (must use RPC functions)

---

### `trade_proposal_items`

Individual stickers in each proposal (offer or request).

```sql
CREATE TABLE trade_proposal_items (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  proposal_id BIGINT NOT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  sticker_id INTEGER NOT NULL REFERENCES stickers(id) ON DELETE CASCADE,
  count INTEGER NOT NULL CHECK (count > 0),
  direction TEXT NOT NULL CHECK (direction IN ('offer', 'request')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Design:**

- `direction = 'offer'`: Stickers the sender is offering
- `direction = 'request'`: Stickers the sender is requesting

**Indexes:**

- Primary key on `id`
- `idx_trade_proposal_items_proposal` on `(proposal_id)`

**RLS Policies:**

- Access controlled through parent `trade_proposals` table

---

### `trade_chats`

Chat messages within trade proposals.

```sql
CREATE TABLE trade_chats (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  trade_id BIGINT NOT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  sender_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  message TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Indexes:**

- Primary key on `id`
- `idx_trade_chats_trade_created_at` on `(trade_id, created_at)` for chronological loading

**RLS Policies:**

- Only proposal participants can read/write messages
- Messages are immutable once created

---

### `trade_reads` âœ… **v1.4.2 NEW**

Tracks last read timestamp for each user per trade (for unread message badges).

```sql
CREATE TABLE trade_reads (
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  trade_id BIGINT NOT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  last_read_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  PRIMARY KEY (user_id, trade_id)
);
```

**Design:**

- `user_id`: User who read the trade
- `trade_id`: Trade proposal ID
- `last_read_at`: Timestamp of last read action

**Indexes:**

- Primary key on `(user_id, trade_id)`
- `idx_trade_reads_user_id` on `(user_id)` for user lookups
- `idx_trade_reads_trade_id` on `(trade_id)` for trade lookups

**RLS Policies:**

- Owner-only access: `user_id = auth.uid()` for SELECT, INSERT, UPDATE, DELETE
- Users can only read/modify their own read timestamps

**Usage:**

- Upserted via `mark_trade_read(p_trade_id)` RPC when user opens chat
- Queried via `get_unread_counts(p_box, p_trade_ids)` RPC for badge counts

---

### `trades_history`

Terminal state tracking for completed/cancelled trades.

```sql
CREATE TABLE trades_history (
  trade_id BIGINT PRIMARY KEY REFERENCES trade_proposals(id) ON DELETE CASCADE,
  status TEXT NOT NULL CHECK (status IN ('completed', 'cancelled')),
  completed_at TIMESTAMPTZ,
  cancelled_at TIMESTAMPTZ,
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb
);
```

**Design:**

- Single row per trade once it reaches terminal state
- `metadata`: Reserved for audit trails, ratings, etc.

**Indexes:**

- Primary key on `trade_id`

**RLS Policies:**

- Only proposal participants can read history

---

### `trade_finalizations` _(v1.4.4)_

Two-step handshake for trade completion.

```sql
CREATE TABLE trade_finalizations (
  trade_id BIGINT NOT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  finalized_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  PRIMARY KEY (trade_id, user_id)
);
```

**Design:**

- Composite PK ensures each user can only finalize once per trade
- Both participants must finalize before trade moves to `trades_history`
- `finalized_at`: Timestamp when user confirmed finalization

**Indexes:**

- Primary key on `(trade_id, user_id)`
- `idx_trade_finalizations_trade_id` on `(trade_id)` for counting participants

**RLS Policies:**

- Only proposal participants can read finalization status
- Users can only insert their own finalization records
- No updates or deletes allowed (immutable once created)

**Usage:**

- Insert via `mark_trade_finalized(p_trade_id)` RPC
- RPC returns `both_finalized` boolean
- When both finalized, trade automatically moves to `trades_history` with status 'completed'

---

### `notifications` _(v1.4.4)_

User notifications for chat messages, proposal status changes, and finalization requests.

```sql
CREATE TABLE notifications (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  kind TEXT NOT NULL CHECK (kind IN ('chat_unread', 'proposal_accepted', 'proposal_rejected', 'finalization_requested')),
  trade_id BIGINT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  read_at TIMESTAMPTZ NULL,
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb
);
```

**Design:**

- `kind`: Notification type (4 types for MVP)
  - `chat_unread`: Unread chat messages (coalesced per trade)
  - `proposal_accepted`: Proposal was accepted
  - `proposal_rejected`: Proposal was rejected
  - `finalization_requested`: Counterparty requested finalization
- `trade_id`: Associated trade (NULL for system notifications)
- `read_at`: NULL for unread, timestamp when marked read
- `metadata`: JSON blob for additional data (e.g., last_message_id, requester_id)

**Indexes:**

- Primary key on `id`
- `idx_notifications_user_read` on `(user_id, read_at)` for unread queries
- `idx_notifications_user_kind_read` on `(user_id, kind, read_at)` for filtering by type
- `idx_notifications_user_trade_kind_read` on `(user_id, trade_id, kind, read_at)` for trade-specific queries
- `idx_notifications_trade_id` on `(trade_id)` for trade lookups
- `idx_notifications_user_trade_kind_unread_unique` (UNIQUE partial index) on `(user_id, trade_id, kind)` WHERE `kind = 'chat_unread' AND read_at IS NULL` for chat notification coalescing

**RLS Policies:**

- Users can only see their own notifications (`user_id = auth.uid()`)
- Users can only insert their own notifications (for RPC/trigger usage)
- Users can only update/delete their own notifications

**Triggers:**

- `trigger_notify_chat_message`: Creates/updates `chat_unread` notification when new chat message is inserted
- `trigger_notify_proposal_status_change`: Creates notification when proposal status changes to `accepted` or `rejected`
- `trigger_notify_finalization_requested`: Creates notification when counterparty marks trade as finalized

**Usage:**

- Query via `get_notifications()` RPC (returns enriched data with trade details)
- Count via `get_notification_count()` RPC (returns unread count)
- Mark all read via `mark_all_notifications_read()` RPC

---

## Admin & Audit (v1.5.0)

### `audit_log`

Append-only audit log of admin actions.

```sql
CREATE TABLE audit_log (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  entity TEXT NOT NULL, -- 'collection' | 'page' | 'sticker'
  entity_id BIGINT,
  action TEXT NOT NULL, -- 'create' | 'update' | 'delete' | 'bulk_upload'
  before_json JSONB,
  after_json JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Design:**

- **Append-only**: No updates or deletes allowed (enforced via RLS)
- **Entity tracking**: Records which table and record ID was affected
- **Action types**: create, update, delete, bulk_upload
- **Snapshot storage**: `before_json` and `after_json` store full record state
- **Admin only**: Populated by SECURITY DEFINER admin RPCs

**Indexes:**

- Primary key on `id`
- `idx_audit_log_user_id` on `(user_id)` for user-specific queries
- `idx_audit_log_entity` on `(entity, entity_id)` for entity-specific history
- `idx_audit_log_created_at` on `(created_at DESC)` for time-based queries

**RLS Policies:**

- Admins can read all audit entries
- Non-admins cannot access audit_log
- No UPDATE or DELETE allowed (append-only)

**Usage:**

- Populated automatically by admin RPCs on create/update/delete operations
- Used for compliance, debugging, and administrative oversight

---

## Location Matching (v1.5.0)

### `postal_codes`

Centroid data for location-based trade matching.

```sql
CREATE TABLE postal_codes (
  country CHAR(2) NOT NULL DEFAULT 'ES',
  postcode VARCHAR(10) NOT NULL,
  lat DOUBLE PRECISION NOT NULL,
  lon DOUBLE PRECISION NOT NULL,
  PRIMARY KEY (country, postcode)
);

CREATE INDEX idx_postal_codes_postcode ON postal_codes(postcode);
```

**Design:**

- **Centroid approach**: Stores lat/lon for postcode center (not exact addresses)
- **Privacy-preserving**: Distance calculated from postcode centroids
- **Country support**: Initially Spanish postcodes (ES), extensible to other countries
- **Indexed**: Fast lookups for distance calculations

**Usage:**

- Populated via admin import (CSV/XLSX of postcode centroids)
- Used by `find_mutual_traders` RPC to calculate Haversine distance
- Distance shown in UI (~12 km) without revealing exact locations

**Haversine Formula:**

```sql
-- Distance in kilometers between two lat/lon points
CREATE OR REPLACE FUNCTION haversine_distance(
  lat1 DOUBLE PRECISION,
  lon1 DOUBLE PRECISION,
  lat2 DOUBLE PRECISION,
  lon2 DOUBLE PRECISION
) RETURNS DOUBLE PRECISION AS $$
DECLARE
  earth_radius CONSTANT DOUBLE PRECISION := 6371; -- km
  dlat DOUBLE PRECISION;
  dlon DOUBLE PRECISION;
  a DOUBLE PRECISION;
  c DOUBLE PRECISION;
BEGIN
  dlat := RADIANS(lat2 - lat1);
  dlon := RADIANS(lon2 - lon1);
  a := SIN(dlat/2)^2 + COS(RADIANS(lat1)) * COS(RADIANS(lat2)) * SIN(dlon/2)^2;
  c := 2 * ATAN2(SQRT(a), SQRT(1-a));
  RETURN earth_radius * c;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

---

## Badges & Achievements (v1.3.0)

### `user_badges`

User achievement badges.

```sql
CREATE TABLE user_badges (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  badge_code TEXT NOT NULL,
  awarded_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT user_badges_user_code_unique UNIQUE (user_id, badge_code)
);
```

**Design:**

- Service-managed (no direct client writes)
- `badge_code`: Unique identifier for badge type

**Indexes:**

- Primary key on `id`
- Unique constraint on `(user_id, badge_code)`

**RLS Policies:**

- Users can only read their own badges
- No client writes allowed

---

## Database Functions (RPCs)

### Collection Statistics

#### `get_user_collection_stats`

Returns completion statistics for a user's collection. Missing counts are inferred from ownership records (count = 0).

```sql
FUNCTION get_user_collection_stats(
  p_user_id UUID,
  p_collection_id INTEGER
) RETURNS JSON
```

**Returns:**

```json
{
  "total_stickers": 600,
  "owned_stickers": 450,
  "completion_percentage": 75,
  "duplicates": 120,
  "missing": 150,
}
```

**Security:** SECURITY DEFINER

---

#### `get_completion_report` _(v1.3.0)_

Generates per-page completion report.

```sql
FUNCTION get_completion_report(
  p_user_id UUID,
  p_collection_id INTEGER
) RETURNS JSON
```

**Returns:**

```json
{
  "collection_id": 1,
  "pages": [
    {
      "page_id": 1,
      "title": "FC Barcelona",
      "kind": "team",
      "order_index": 1,
      "missing": [1, 5, 12],
      "repes": [3, 7, 15]
    }
  ]
}
```

**Security:** SECURITY DEFINER, requires caller = `p_user_id`

---

### Sticker Management

#### `bulk_add_stickers_by_numbers` _(v1.3.0)_

Add multiple stickers by their numbers in one operation.

```sql
FUNCTION bulk_add_stickers_by_numbers(
  p_user_id UUID,
  p_collection_id INTEGER,
  p_numbers INTEGER[]
) RETURNS JSON
```

**Returns:**

```json
{
  "added": 5,
  "duplicates": [12, 15],
  "invalid": [999]
}
```

**Security:** SECURITY DEFINER, requires caller = `p_user_id`

---

#### `search_stickers` _(v1.3.0)_

Search stickers with filters and ownership status.

```sql
FUNCTION search_stickers(
  p_collection_id INTEGER,
  p_query TEXT,
  p_filters JSONB
) RETURNS SETOF sticker_search_result
```

**Filters:**

```json
{
  "owned": true,
  "missing": false,
  "repes": true,
  "kind": "team"
}
```

**Security:** SECURITY DEFINER, authenticated users only

---

### Trading - Discovery

#### `find_mutual_traders` (Enhanced v1.5.0)

Find users with mutual trading opportunities. Sticker intent is inferred from inventory counts: a sticker is missing when the seeker has `count = 0`, and a tradeable duplicate is available when the owner has `count > 1`.

**v1.5.0 Enhancement**: Added location-based scoring with Haversine distance calculation.

```sql
FUNCTION find_mutual_traders(
  p_user_id UUID,
  p_collection_id INTEGER,
  p_rarity TEXT DEFAULT NULL,
  p_team TEXT DEFAULT NULL,
  p_query TEXT DEFAULT NULL,
  p_min_overlap INTEGER DEFAULT 1,
  p_limit INTEGER DEFAULT 20,
  p_offset INTEGER DEFAULT 0,
  -- v1.5.0: Location-based parameters
  p_lat DOUBLE PRECISION DEFAULT NULL,
  p_lon DOUBLE PRECISION DEFAULT NULL,
  p_radius_km INTEGER DEFAULT NULL,
  p_sort TEXT DEFAULT 'mixed' -- 'distance' | 'overlap' | 'mixed'
) RETURNS TABLE (
  match_user_id UUID,
  nickname TEXT,
  postcode TEXT, -- v1.5.0: For distance display (optional)
  overlap_from_them_to_me BIGINT,
  overlap_from_me_to_them BIGINT,
  total_mutual_overlap BIGINT,
  distance_km DOUBLE PRECISION, -- v1.5.0: NULL if no location data
  score DOUBLE PRECISION -- v1.5.0: Mixed score (0.6 * normalized_overlap + 0.4 * distance_decay)
)
```

**v1.5.0 Location Parameters:**

- `p_lat`, `p_lon`: User's location from postcode centroid (from `postal_codes` table)
- `p_radius_km`: Filter matches within radius (e.g., 10, 25, 50, 100 km)
- `p_sort`: Sort mode
  - `'overlap'`: Traditional sort by overlap count (DESC)
  - `'distance'`: Sort by distance (ASC, closest first)
  - `'mixed'`: Weighted score = 0.6 Ã— (overlap / max_overlap) + 0.4 Ã— (1 - distance / max_distance)

**Mixed Scoring Algorithm:**

```sql
-- Normalize overlap to 0-1 range
normalized_overlap := overlap / NULLIF(MAX(overlap) OVER (), 0)

-- Normalize distance with decay (closer = higher score)
distance_decay := 1 - (distance_km / NULLIF(MAX(distance_km) OVER (), 0))

-- Final score (60% overlap weight, 40% proximity weight)
score := 0.6 * normalized_overlap + 0.4 * distance_decay
```

**Privacy Note:** Only postcode is stored (not exact address). Distance calculated from centroid.

**Security:** SECURITY DEFINER

---

#### `get_mutual_trade_detail`

Get detailed sticker lists for a trading pair. Rows are emitted with `direction = 'they_offer'` when the other user has duplicates (`count > 1`) and the current user has none (`count = 0`), and `direction = 'i_offer'` for the inverse.

```sql
FUNCTION get_mutual_trade_detail(
  p_user_id UUID,
  p_other_user_id UUID,
  p_collection_id INTEGER
) RETURNS TABLE (
  direction TEXT,
  sticker_id INTEGER,
  sticker_code TEXT,
  player_name TEXT,
  team_name TEXT,
  rarity TEXT,
  count INTEGER
)
```

**Security:** SECURITY DEFINER

---

### Trading - Proposals

#### `create_trade_proposal`

Create a new trade proposal. The message is stored as the first chat message, not in the proposal record.

```sql
FUNCTION create_trade_proposal(
  p_collection_id INTEGER,
  p_to_user UUID,
  p_offer_items proposal_item[],
  p_request_items proposal_item[],
  p_message TEXT
) RETURNS BIGINT
```

**Parameters:**
- `p_collection_id`: The collection ID for the trade
- `p_to_user`: UUID of the user receiving the proposal
- `p_offer_items`: Array of items the sender is offering
- `p_request_items`: Array of items the sender is requesting
- `p_message`: Optional message (stored as first chat message if provided)

**Returns:** The proposal ID (BIGINT)

**Behavior:**
- Creates a trade proposal with status 'pending'
- Inserts offer and request items into trade_proposal_items
- If a message is provided, inserts it as the first message in trade_chats
- The proposal.message field is always NULL (messages go to trade_chats)

**Security:** SECURITY DEFINER

---

#### `respond_to_trade_proposal`

Accept, reject, or cancel a proposal.

```sql
FUNCTION respond_to_trade_proposal(
  p_proposal_id INTEGER,
  p_action TEXT
) RETURNS JSON
```

**Actions:** `'accept'`, `'reject'`, `'cancel'`

**Security:** SECURITY DEFINER

---

#### `list_trade_proposals`

List inbox or outbox proposals.

```sql
FUNCTION list_trade_proposals(
  p_user_id UUID,
  p_box TEXT,
  p_limit INTEGER DEFAULT 20,
  p_offset INTEGER DEFAULT 0
) RETURNS TABLE (...)
```

**Box:** `'inbox'` or `'outbox'`

**Security:** SECURITY DEFINER

---

#### `get_trade_proposal_detail`

Get complete proposal details.

```sql
FUNCTION get_trade_proposal_detail(
  p_proposal_id INTEGER
) RETURNS JSON
```

**Security:** SECURITY DEFINER

---

### Trading - History

#### `complete_trade` _(v1.3.0)_

Mark a trade as completed.

```sql
FUNCTION complete_trade(
  p_trade_id BIGINT
) RETURNS VOID
```

**Security:** SECURITY DEFINER, only participants

---

#### `cancel_trade` _(v1.3.0)_

Cancel a trade.

```sql
FUNCTION cancel_trade(
  p_trade_id BIGINT
) RETURNS VOID
```

**Security:** SECURITY DEFINER, only participants

---

### Trading - Chat & Unread Badges âœ… **v1.4.2 NEW**

#### `mark_trade_read`

Mark a trade as read for the current user (upserts last_read_at timestamp).

```sql
FUNCTION mark_trade_read(
  p_trade_id BIGINT
) RETURNS VOID
```

**Parameters:**

- `p_trade_id`: Trade proposal ID (required)

**Behavior:**

- Automatically uses `auth.uid()` for user_id (SECURITY DEFINER)
- Upserts `trade_reads` row with `last_read_at = NOW()`
- Validates user is a participant in the trade
- Raises exception if not authenticated or not a participant

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { error } = await supabase.rpc('mark_trade_read', {
  p_trade_id: tradeId,
});

if (error) {
  console.error('Error marking trade as read:', error);
}
```

---

#### `get_unread_counts`

Returns unread message counts per trade for the current user in the specified box.

```sql
FUNCTION get_unread_counts(
  p_box TEXT,
  p_trade_ids INT8[] DEFAULT NULL
) RETURNS TABLE (
  trade_id BIGINT,
  unread_count BIGINT
)
```

**Parameters:**

- `p_box`: Box to query (`'inbox'` or `'outbox'`) (required)
- `p_trade_ids`: Optional array of trade IDs to filter by (for pagination)

**Returns:**

Array of objects with:
- `trade_id`: Trade proposal ID
- `unread_count`: Number of unread messages from counterparty

**Behavior:**

- Automatically scopes to `auth.uid()` (SECURITY DEFINER)
- Filters trades by box:
  - `inbox`: trades where `to_user = auth.uid()`
  - `outbox`: trades where `from_user = auth.uid()`
- Counts messages from counterparty (`sender_id <> auth.uid()`) where `created_at > COALESCE(last_read_at, 'epoch')`
- Returns 0 for trades with no unread messages
- If `p_trade_ids` provided, only returns counts for those trades

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { data, error } = await supabase.rpc('get_unread_counts', {
  p_box: 'inbox',
  p_trade_ids: [123, 456, 789], // Optional
});

if (error) throw error;

// data = [{ trade_id: 123, unread_count: 5 }, { trade_id: 456, unread_count: 0 }, ...]
const unreadMap = new Map(data.map(item => [item.trade_id, item.unread_count]));
```

---

### Sticker Completion

#### `mark_team_page_complete` _(v1.4.0)_

Marks all stickers on a team page as owned (count=1) for a user. Only adds stickers that are currently missing (no row or count=0). Idempotent - returns added_count=0 if page already complete.

```sql
FUNCTION mark_team_page_complete(
  p_user_id UUID,
  p_collection_id INT,
  p_page_id INT
) RETURNS JSONB
```

**Parameters:**

- `p_user_id`: User UUID (must match authenticated user)
- `p_collection_id`: Collection ID that owns the page
- `p_page_id`: Page ID to mark complete (must be a team page)

**Returns:**

```json
{
  "added_count": 5,
  "affected_sticker_ids": [1, 5, 12, 18, 20]
}
```

**Preconditions:**

- User must be authenticated (`auth.uid()`)
- Caller must be acting on their own behalf (`p_user_id = auth.uid()`)
- Page must belong to the specified collection
- Page must be a team page (`kind = 'team'` or exactly 20 slots)

**Side Effects:**

- Inserts new rows into `user_stickers` with `count = 1` for missing stickers
- Updates existing rows where `count = 0` to `count = 1`
- Does NOT modify stickers with `count >= 1` (preserves singles and duplicates)
- Idempotent: re-running on same page returns `added_count = 0`

**Security:**

- `SECURITY DEFINER`: Runs with elevated privileges
- Auth guard: Validates `p_user_id = auth.uid()` at function start
- RLS remains enabled on `user_stickers` table
- Cross-user writes blocked by exception

**Scope:**

- **Team pages only**: Badge + manager + 18 players (20 slots)
- **Special pages**: Not supported in Phase 1 (raises exception)

**Error Cases:**

- Cross-user write: `Unauthorized: Cannot modify stickers for another user`
- Invalid page/collection: `Invalid page_id X for collection_id Y`
- Non-team page: `Only team pages are supported` (SQLSTATE `check_violation`)
- RLS violations: Standard Supabase RLS errors

**Full Implementation:**

```sql
-- Drop existing function if it exists
DROP FUNCTION IF EXISTS mark_team_page_complete(UUID, INT, INT);

-- Create the function with team page validation
CREATE OR REPLACE FUNCTION mark_team_page_complete(
    p_user_id UUID,
    p_collection_id INT,
    p_page_id INT
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO public
AS $$
DECLARE
    v_added_count INT := 0;
    v_affected_sticker_ids INT[] := ARRAY[]::INT[];
    v_page_exists BOOLEAN;
    v_page_kind TEXT;
    v_slot_count INT;
BEGIN
    -- Security: Verify the caller is acting on their own behalf
    IF p_user_id <> auth.uid() THEN
        RAISE EXCEPTION 'Unauthorized: Cannot modify stickers for another user';
    END IF;

    -- Validate that the page belongs to the collection and get page kind
    SELECT
        EXISTS(
            SELECT 1
            FROM collection_pages
            WHERE id = p_page_id
              AND collection_id = p_collection_id
        ),
        (SELECT kind FROM collection_pages WHERE id = p_page_id)
    INTO v_page_exists, v_page_kind;

    IF NOT v_page_exists THEN
        RAISE EXCEPTION 'Invalid page_id % for collection_id %', p_page_id, p_collection_id;
    END IF;

    -- Guard: Only allow team pages
    -- First try to use collection_pages.kind if available
    IF v_page_kind IS NOT NULL THEN
        -- Column exists, use it directly
        IF v_page_kind <> 'team' THEN
            RAISE EXCEPTION 'Only team pages are supported'
                USING ERRCODE = 'check_violation';
        END IF;
    ELSE
        -- Fallback: check slot count (team pages have exactly 20 slots)
        SELECT COUNT(*)
        INTO v_slot_count
        FROM page_slots
        WHERE page_id = p_page_id;

        IF v_slot_count <> 20 THEN
            RAISE EXCEPTION 'Only team pages are supported'
                USING ERRCODE = 'check_violation';
        END IF;
    END IF;

    -- Insert missing stickers (count = 0 or no row) and collect affected IDs
    WITH page_stickers AS (
        -- Get all stickers on this page that belong to the collection
        SELECT ps.sticker_id
        FROM page_slots ps
        INNER JOIN stickers s ON s.id = ps.sticker_id
        WHERE ps.page_id = p_page_id
          AND s.collection_id = p_collection_id
    ),
    missing_stickers AS (
        -- Find stickers that are missing (no row or count = 0)
        SELECT ps.sticker_id
        FROM page_stickers ps
        LEFT JOIN user_stickers us ON
            us.user_id = p_user_id
            AND us.sticker_id = ps.sticker_id
        WHERE us.sticker_id IS NULL OR us.count = 0
    ),
    inserted AS (
        -- Upsert: insert new rows or update count to 1 where it was 0
        INSERT INTO user_stickers (user_id, sticker_id, count)
        SELECT p_user_id, sticker_id, 1
        FROM missing_stickers
        ON CONFLICT (user_id, sticker_id)
        DO UPDATE SET count = 1
        WHERE user_stickers.count = 0
        RETURNING sticker_id
    )
    SELECT
        COUNT(*)::INT,
        ARRAY_AGG(sticker_id ORDER BY sticker_id)
    INTO v_added_count, v_affected_sticker_ids
    FROM inserted;

    -- Handle case where no stickers were added
    IF v_affected_sticker_ids IS NULL THEN
        v_affected_sticker_ids := ARRAY[]::INT[];
    END IF;

    RETURN jsonb_build_object(
        'added_count', v_added_count,
        'affected_sticker_ids', v_affected_sticker_ids
    );
END;
$$;

-- Revoke all permissions from public
REVOKE ALL ON FUNCTION mark_team_page_complete(UUID, INT, INT) FROM PUBLIC;

-- Grant execute to authenticated users
GRANT EXECUTE ON FUNCTION mark_team_page_complete(UUID, INT, INT) TO authenticated;

-- Add function comment
COMMENT ON FUNCTION mark_team_page_complete(UUID, INT, INT) IS
'Marks all stickers on a team page as owned (count=1) for a user. Only adds stickers that are currently missing (no row or count=0). Idempotent - returns added_count=0 if page already complete. Only supports team pages (kind=team or exactly 20 slots).';
```

---

## Admin RPCs (v1.5.0)

### Collections Management

#### `admin_upsert_collection`

Create or update a collection (admin only).

```sql
FUNCTION admin_upsert_collection(
  p_collection JSONB
) RETURNS JSONB
```

**Parameters:**
- `p_collection`: JSON object with collection fields (id optional for create)
  - `id` (optional): Collection ID for update
  - `name`: Collection name
  - `competition`: Competition name
  - `year`: Year
  - `description`: Description
  - `image_url`: Cover image URL
  - `is_active`: Active status (defaults to true)

**Returns:**
```json
{
  "id": 123,
  "name": "LaLiga 2025-26",
  "created": true
}
```

**Security:** SECURITY DEFINER, requires `is_admin = TRUE` in JWT claims

---

#### `admin_delete_collection`

Delete a collection (admin only).

```sql
FUNCTION admin_delete_collection(
  p_collection_id BIGINT
) RETURNS VOID
```

**Security:** SECURITY DEFINER, requires admin, cascades to pages/stickers/user data

---

### Pages Management

#### `admin_upsert_page`

Create or update a collection page.

```sql
FUNCTION admin_upsert_page(
  p_page JSONB
) RETURNS JSONB
```

**Parameters:**
- `p_page`: JSON object with page fields
  - `id` (optional): Page ID for update
  - `collection_id`: Parent collection
  - `kind`: 'team' or 'special'
  - `team_id`: Team ID (required if kind='team')
  - `title`: Page title
  - `order_index`: Sort order

**Returns:**
```json
{
  "id": 456,
  "title": "FC Barcelona",
  "created": false
}
```

**Security:** SECURITY DEFINER, requires admin

---

#### `admin_delete_page`

Delete a page and its slots.

```sql
FUNCTION admin_delete_page(
  p_page_id BIGINT
) RETURNS VOID
```

**Security:** SECURITY DEFINER, requires admin, cascades to page_slots

---

### Stickers Management

#### `admin_upsert_sticker`

Create or update a sticker.

```sql
FUNCTION admin_upsert_sticker(
  p_sticker JSONB
) RETURNS JSONB
```

**Parameters:**
- `p_sticker`: JSON object with sticker fields
  - `id` (optional): Sticker ID for update
  - `collection_id`: Parent collection
  - `team_id`: Team ID (optional)
  - `code`: Sticker code
  - `player_name`: Player name
  - `position`: Position (optional)
  - `nationality`: Nationality (optional)
  - `rating`: Rating (optional)
  - `rarity`: Rarity ('common', 'rare', 'epic', 'legendary')
  - `image_url`: External image URL (optional)
  - `sticker_number`: Sequential number (optional for now)
  - `image_path_webp_300`: Storage path for 300px WebP (optional)
  - `thumb_path_webp_100`: Storage path for 100px thumb (optional)

**Returns:**
```json
{
  "id": 789,
  "code": "BAR001",
  "player_name": "Lionel Messi",
  "created": true
}
```

**Security:** SECURITY DEFINER, requires admin

---

#### `admin_delete_sticker`

Delete a sticker.

```sql
FUNCTION admin_delete_sticker(
  p_sticker_id BIGINT
) RETURNS VOID
```

**Security:** SECURITY DEFINER, requires admin, cascades to user_stickers/page_slots

---

### Bulk Upload

#### `admin_bulk_upload_preview`

Preview bulk upload changes without applying them.

```sql
FUNCTION admin_bulk_upload_preview(
  p_upload_data JSONB
) RETURNS JSONB
```

**Parameters:**
- `p_upload_data`: JSON array of stickers/pages/collections with validation rules

**Returns:**
```json
{
  "valid_rows": 50,
  "invalid_rows": 2,
  "errors": [
    {"row": 12, "error": "Missing required field: player_name"},
    {"row": 25, "error": "Duplicate sticker code: BAR001"}
  ],
  "warnings": [
    {"row": 5, "warning": "sticker_number is optional but recommended"}
  ],
  "diffs": [
    {"action": "create", "entity": "sticker", "data": {...}},
    {"action": "update", "entity": "sticker", "id": 123, "changes": {...}}
  ]
}
```

**Security:** SECURITY DEFINER, requires admin, read-only (no writes)

---

#### `admin_bulk_upload_apply`

Apply bulk upload changes after preview approval.

```sql
FUNCTION admin_bulk_upload_apply(
  p_upload_data JSONB
) RETURNS JSONB
```

**Parameters:**
- `p_upload_data`: Same structure as preview

**Returns:**
```json
{
  "created": 45,
  "updated": 5,
  "failed": 0,
  "audit_log_entries": 50
}
```

**Behavior:**
- Transactional: all or nothing
- Populates audit_log for each operation
- Uploads images to Supabase Storage (WebP conversion + thumbnails)
- Returns summary of operations

**Security:** SECURITY DEFINER, requires admin

---

**Image Upload Note:**
Admin bulk upload automatically:
1. Accepts uploaded images (PNG/JPG/WebP)
2. Converts to WebP format
3. Generates 300px full-size and 100px thumbnail
4. Uploads to `sticker-images/{collection_id}/` and `sticker-images/{collection_id}/thumbs/`
5. Populates `image_path_webp_300` and `thumb_path_webp_100` in stickers table

---

## Triggers

### `handle_updated_at`

Automatically updates `updated_at` column on row modifications.

Applied to:

- `profiles`
- `user_stickers`
- `trade_proposals`

---

## Supabase Storage Buckets

### `sticker-images`

Stores sticker artwork.

**Structure:**

```
sticker-images/
â”œâ”€â”€ {collection_id}/
â”‚   â”œâ”€â”€ {sticker_number}-{sticker_id}.webp (300px)
â”‚   â””â”€â”€ thumbs/
â”‚       â””â”€â”€ {sticker_number}-{sticker_id}.webp (100px)
```

**Configuration:**

- Public read access
- Authenticated write only
- Max file size: 5MB
- Allowed MIME types: `image/webp`, `image/png`, `image/jpeg`

---

### `avatars`

Stores user profile avatars.

**Configuration:**

- Public read access
- Authenticated write only
- Max file size: 2MB
- Allowed MIME types: `image/webp`, `image/png`, `image/jpeg`

---

## Migration Notes

### Deployment Checklist

1. âœ… All core tables created
2. âœ… All indexes applied
3. âœ… All RLS policies active
4. âœ… All RPC functions deployed
5. âœ… Storage buckets configured
6. âš ï¸ Backfill `stickers.sticker_number` before enforcing NOT NULL
7. âš ï¸ Populate `collection_pages` and `page_slots` for active collections

### Performance Monitoring

Key indexes for monitoring:

- `idx_user_stickers_trading_v2` (Phase 1 high traffic)
- `idx_user_stickers_trading` (kept during transition)
- `idx_stickers_collection_filters` (trading queries)
- `idx_trade_proposals_to_user` (inbox queries)
- `idx_collection_pages_order` (album navigation)
- `idx_page_slots_page_id` (page completion queries - v1.4.0)
- `idx_user_stickers_user_collection_sticker_count` (page completion queries - v1.4.0)

---

## Performance Indexes (v1.4.0)

The following indexes optimize the `mark_team_page_complete` function and related page-based operations:

```sql
-- Indexes for mark_team_page_complete performance
-- These support fast lookups in the function's CTEs

-- Index for page_slots: quick lookup of all stickers on a given page
CREATE INDEX IF NOT EXISTS idx_page_slots_page_id
ON page_slots(page_id);

-- Composite index for page_slots: covers both columns used in joins
CREATE INDEX IF NOT EXISTS idx_page_slots_page_sticker
ON page_slots(page_id, sticker_id);

-- Index for user_stickers: fast lookup by user + collection + sticker
-- This supports the LEFT JOIN in missing_stickers CTE
CREATE INDEX IF NOT EXISTS idx_user_stickers_user_collection_sticker
ON user_stickers(user_id, collection_id, sticker_id);

-- Additional index including count for filtering count = 0
CREATE INDEX IF NOT EXISTS idx_user_stickers_user_collection_sticker_count
ON user_stickers(user_id, collection_id, sticker_id, count);

-- Index for collection_pages: validate page belongs to collection
CREATE INDEX IF NOT EXISTS idx_collection_pages_page_collection
ON collection_pages(page_id, collection_id);

-- Alternative index if collection_pages has 'id' as primary key
CREATE INDEX IF NOT EXISTS idx_collection_pages_collection
ON collection_pages(collection_id);

/*
EXPECTED QUERY PLAN SHAPE:
============================

1. Page validation (collection_pages):
   -> Index Scan using idx_collection_pages_page_collection
   -> Should be instant lookup

2. page_stickers CTE (page_slots):
   -> Index Scan using idx_page_slots_page_id
   -> Returns ~20 rows for team pages

3. missing_stickers CTE (LEFT JOIN):
   -> Nested Loop Left Join
      -> Seq Scan on page_stickers (small CTE, ~20 rows)
      -> Index Scan using idx_user_stickers_user_collection_sticker
   -> Filter on (us.sticker_id IS NULL OR us.count = 0)

4. INSERT with ON CONFLICT:
   -> Uses unique constraint on (user_id, collection_id, sticker_id)
   -> Supported by idx_user_stickers_user_collection_sticker

Overall: Should be < 10ms for typical team page (20 stickers)
Key: All joins use index scans, no table scans except tiny CTEs
*/
```

---

### Trade Finalization _(v1.4.4)_

#### `mark_trade_finalized`

Two-step handshake for trade completion. Both participants must call this function before the trade is marked as completed.

```sql
FUNCTION mark_trade_finalized(
  p_trade_id BIGINT
) RETURNS JSONB
```

**Parameters:**

- `p_trade_id`: Trade proposal ID (required)

**Returns:**

```json
{
  "both_finalized": true,
  "finalized_count": 2
}
```

**Behavior:**

- Automatically uses `auth.uid()` for user_id (SECURITY DEFINER)
- Validates user is a participant in the trade (from_user or to_user)
- Inserts finalization record for current user
- Checks if both participants have finalized
- If both finalized, automatically creates `trades_history` record with status 'completed'
- Idempotent - calling multiple times by same user has no effect
- Raises exception if not authenticated or not a participant

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { data, error } = await supabase.rpc('mark_trade_finalized', {
  p_trade_id: tradeId,
});

if (error) {
  console.error('Error finalizing trade:', error);
  return;
}

if (data.both_finalized) {
  toast.success('Â¡Intercambio finalizado! Ambos participantes confirmaron.');
  // Close modal, refresh history, etc.
} else {
  toast.success(`Confirmado. Esperando confirmaciÃ³n de la otra parte (${data.finalized_count}/2).`);
}
```

---

### Notifications _(v1.4.4)_

#### `get_notifications`

Returns all notifications for the current user with enriched trade details.

```sql
FUNCTION get_notifications()
RETURNS TABLE (
  id BIGINT,
  kind TEXT,
  trade_id BIGINT,
  created_at TIMESTAMPTZ,
  read_at TIMESTAMPTZ,
  metadata JSONB,
  proposal_from_user UUID,
  proposal_to_user UUID,
  proposal_status TEXT,
  from_user_nickname TEXT,
  to_user_nickname TEXT
)
```

**Returns:**

Array of notification objects with joined trade proposal and profile data:
- `id`: Notification ID
- `kind`: Notification type (chat_unread, proposal_accepted, proposal_rejected, finalization_requested)
- `trade_id`: Associated trade ID
- `created_at`: When notification was created
- `read_at`: When notification was marked read (NULL if unread)
- `metadata`: Additional JSON data
- `proposal_from_user`: UUID of proposal sender
- `proposal_to_user`: UUID of proposal recipient
- `proposal_status`: Current status of trade proposal
- `from_user_nickname`: Sender's nickname
- `to_user_nickname`: Recipient's nickname

**Behavior:**

- Automatically scopes to `auth.uid()` (SECURITY DEFINER)
- Ordered by unread first, then by creation date descending
- Includes LEFT JOIN to trade_proposals and profiles for enriched data

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { data: notifications, error } = await supabase.rpc('get_notifications');

if (error) throw error;

// data is enriched with trade and profile information
```

---

#### `get_notification_count`

Returns count of unread notifications for the current user.

```sql
FUNCTION get_notification_count()
RETURNS INTEGER
```

**Returns:**

Integer count of notifications where `read_at IS NULL`

**Behavior:**

- Automatically scopes to `auth.uid()` (SECURITY DEFINER)
- Fast count query using indexed `read_at` column

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { data: count, error } = await supabase.rpc('get_notification_count');

if (error) throw error;

// Display badge with count
setBadgeCount(count);
```

---

#### `mark_all_notifications_read`

Marks all unread notifications as read for the current user.

```sql
FUNCTION mark_all_notifications_read()
RETURNS VOID
```

**Behavior:**

- Automatically scopes to `auth.uid()` (SECURITY DEFINER)
- Updates all notifications where `read_at IS NULL` to `read_at = NOW()`
- Idempotent - safe to call multiple times

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { error } = await supabase.rpc('mark_all_notifications_read');

if (error) {
  console.error('Error marking notifications as read:', error);
  return;
}

// Refresh notification list
```

---

## Schema Version History

- **v1.5.0** (Current): Critical fixes (batch RPC, ErrorBoundary), Admin Backoffice (RBAC, audit log), Location Matching (Haversine), Badges UI, Quick Entry, Avatar Seed
- **v1.4.4**: Trade finalization handshake, notifications system (MVP)
- **v1.4.3**: Trade flow optimization, SegmentedTabs component
- **v1.4.2**: Trade composer UX improvements, trade matching logic fixes
- **v1.4.1**: Complete Retro-Comic theme rollout
- **v1.4.0**: Mark team page complete feature, schema cleanup
- **v1.3.0**: Album pages, trade history, badges, enhanced sticker images
- **v1.2.0**: Complete trade proposals system
- **v1.1.0**: Trading discovery (find mutual traders)
- **v1.0.0**: Core collection and sticker management

---

**Status:** ðŸš§ v1.5.0 schema documented (pre-implementation)
**Next:**
1. Critical fixes (1 day) â†’ batch RPC, ErrorBoundary, logger
2. Implement Admin RPCs â†’ Location matching RPC â†’ Admin UI â†’ Badges UI â†’ Quick Entry â†’ Avatar Seed
3. High priority: TanStack Query, Zod, CSRF, hook refactoring
