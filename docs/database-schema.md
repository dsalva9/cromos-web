# Database Schema Updates - Collection Management
## v1.3.0-alpha: Album Pages & Trade Chat Foundations

### Stickers Table Extensions

```sql
ALTER TABLE public.stickers
  ADD COLUMN IF NOT EXISTS sticker_number INTEGER,
  ADD COLUMN IF NOT EXISTS image_path_webp_300 TEXT,
  ADD COLUMN IF NOT EXISTS thumb_path_webp_100 TEXT;

-- TODO: backfill sticker_number/image assets before enforcing NOT NULL.

CREATE UNIQUE INDEX IF NOT EXISTS idx_stickers_collection_number_unique
  ON public.stickers (collection_id, sticker_number)
  WHERE sticker_number IS NOT NULL;
```

- `sticker_number` is unique per collection via the partial index above.
- New media columns store pre-processed WebP assets (full 300px + thumb 100px).
- Keep the column nullable until backfill jobs populate existing rows.

### New Tables

#### `collection_pages`

```sql
CREATE TABLE collection_pages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  collection_id INTEGER NOT NULL REFERENCES collections (id) ON DELETE CASCADE,
  kind TEXT NOT NULL CHECK (kind IN ('team', 'special')),
  team_id INTEGER NULL REFERENCES collection_teams (id) ON DELETE SET NULL,
  title TEXT NOT NULL,
  order_index INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT collection_pages_kind_team_check
    CHECK ((kind = 'team' AND team_id IS NOT NULL) OR (kind = 'special' AND team_id IS NULL))
);
```

Teams always bind to a roster page; special pages skip team mapping. Index `idx_collection_pages_order` optimises sorting by `collection_id, order_index`.

#### `page_slots`

```sql
CREATE TABLE page_slots (
  page_id BIGINT NOT NULL REFERENCES collection_pages (id) ON DELETE CASCADE,
  slot_index INTEGER NOT NULL,
  sticker_id INTEGER NULL REFERENCES stickers (id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (page_id, slot_index)
);
```

Slot indexes are zero-based so teams can reserve `0` for the badge, `1` for the manager, and `2-19` for players. The extra covering index (`idx_page_slots_page_slot`) keeps random slot lookups predictable even with the composite PK.

#### `user_badges`

```sql
CREATE TABLE user_badges (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES profiles (id) ON DELETE CASCADE,
  badge_code TEXT NOT NULL,
  awarded_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT user_badges_user_code_unique UNIQUE (user_id, badge_code)
);
```

Badges are service-managed (no direct client writes) and deduplicated per `(user_id, badge_code)` pair.

#### `trade_chats`

```sql
CREATE TABLE trade_chats (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  trade_id BIGINT NOT NULL REFERENCES trade_proposals (id) ON DELETE CASCADE,
  sender_id UUID NOT NULL REFERENCES profiles (id) ON DELETE CASCADE,
  message TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

Primary access control is enforced via RLS to restrict visibility to proposal participants. Index `idx_trade_chats_trade_created_at` backs chronological chat loading.

#### `trades_history`

```sql
CREATE TABLE trades_history (
  trade_id BIGINT PRIMARY KEY REFERENCES trade_proposals (id) ON DELETE CASCADE,
  status TEXT NOT NULL CHECK (status IN ('completed', 'cancelled')),
  completed_at TIMESTAMPTZ,
  cancelled_at TIMESTAMPTZ,
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb
);
```

A single row tracks the terminal outcome of each proposal once the deal is completed or cancelled; metadata is reserved for audit payloads (reason codes, etc.).

### New RPC Functions

#### `bulk_add_stickers_by_numbers(p_user_id UUID, p_collection_id INTEGER, p_numbers INTEGER[]) RETURNS JSON`

- Validates the caller (`auth.uid()`) matches `p_user_id`.
- Deduplicates incoming sticker numbers, inserts new `user_stickers` rows, and increments counts for existing ones.
- Returns `{ added, duplicates, invalid }`, where `added` counts newly owned stickers, `duplicates` lists numbers the user already owned, and `invalid` contains numbers missing from the collection.

#### `get_completion_report(p_user_id UUID, p_collection_id INTEGER) RETURNS JSON`

- Returns `{"collection_id": ..., "pages": [...]}` grouped by `collection_pages`.
- Each page payload includes `missing` (sticker numbers at count `0`) and `repes` (numbers with `count > 1`).
- Requires the caller to be the collection owner; leverages `page_slots` for slot-to-sticker mapping.

#### `search_stickers(p_collection_id INTEGER, p_query TEXT, p_filters JSONB) RETURNS SETOF ...`

- Security definer function limited to authenticated users.
- Supports name/number search plus filters for `owned`, `missing`, `repes`, and `kind` (`team`/`special`).
- Returns sticker metadata enriched with page/slot details and ownership flags.

#### `complete_trade(p_trade_id BIGINT) RETURNS VOID`

- Ensures the caller participates in the trade.
- Upserts into `trades_history` with status `completed`, stamps `completed_at`, and aligns the proposal status to `accepted` unless already cancelled.

#### `cancel_trade(p_trade_id BIGINT) RETURNS VOID`

- Validates caller participation.
- Marks the proposal as `cancelled` and upserts the history row with `cancelled_at`.

### RLS Policy Surface (Additions)

- `collection_pages`, `page_slots`: read-only to clients (`SELECT` allowed, all writes blocked).
- `user_badges`: owners can read; all client writes blocked.
- `trade_chats`: participants can `SELECT`/`INSERT`; updates are blocked to enforce immutable chat history.
- `trades_history`: participants can `SELECT`; other operations denied.

### Deployment Notes

1. Run the new migration `database/migrations/20240927090000_album_pages_trade_chat.sql` in Supabase SQL.
2. Backfill `stickers.sticker_number`, `image_path_webp_300`, and `thumb_path_webp_100` before enforcing non-null constraints.
3. Populate `collection_pages` and `page_slots` per active collections; team pages expect slots `0-19` as described above.
4. Verify RPC grants with `SELECT proname FROM pg_proc WHERE proname IN (...)` to ensure `authenticated` role can invoke the new functions.

## Updated Tables

### `user_collections` (Updated)

User participation in collections with unique constraint and cascade behavior.

```sql
CREATE TABLE user_collections (
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  collection_id INTEGER REFERENCES collections(id) ON DELETE CASCADE,
  is_active BOOLEAN DEFAULT false,
  joined_at TIMESTAMPTZ DEFAULT NOW(),

  PRIMARY KEY (user_id, collection_id),
  -- Ensure only one active collection per user
  CONSTRAINT unique_active_per_user UNIQUE (user_id, is_active) WHERE (is_active = true)
);
```

**New Constraints:**

- `UNIQUE (user_id, collection_id)` - Prevents duplicate collection joins
- `UNIQUE (user_id, is_active) WHERE (is_active = true)` - Ensures only one active collection per user

### `user_stickers` (Updated Cascade)

User's sticker inventory with proper cascade delete.

```sql
CREATE TABLE user_stickers (
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  sticker_id INTEGER REFERENCES stickers(id) ON DELETE CASCADE,
  count INTEGER NOT NULL DEFAULT 0,
  wanted BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  PRIMARY KEY (user_id, sticker_id)
);
```

**Important:** When a `user_collection` is deleted, all associated `user_stickers` for that collection must be deleted via application logic (Supabase RLS handles the constraint).

## New Database Functions

### Collection Management Functions

```sql
-- Remove user collection and all associated sticker data
CREATE OR REPLACE FUNCTION remove_user_collection(
  p_user_id UUID,
  p_collection_id INTEGER
) RETURNS VOID AS $$
BEGIN
  -- Delete user stickers for this collection
  DELETE FROM user_stickers
  WHERE user_id = p_user_id
    AND sticker_id IN (
      SELECT id FROM stickers WHERE collection_id = p_collection_id
    );

  -- Delete user collection
  DELETE FROM user_collections
  WHERE user_id = p_user_id AND collection_id = p_collection_id;

  -- If this was the active collection, make the most recent one active
  IF NOT EXISTS (
    SELECT 1 FROM user_collections
    WHERE user_id = p_user_id AND is_active = true
  ) THEN
    UPDATE user_collections
    SET is_active = true
    WHERE user_id = p_user_id
      AND collection_id = (
        SELECT collection_id FROM user_collections
        WHERE user_id = p_user_id
        ORDER BY joined_at DESC
        LIMIT 1
      );
  END IF;
END;
$$ LANGUAGE plpgsql;

-- Set active collection (ensures only one active)
CREATE OR REPLACE FUNCTION set_active_collection(
  p_user_id UUID,
  p_collection_id INTEGER
) RETURNS VOID AS $$
BEGIN
  -- Set all collections inactive for this user
  UPDATE user_collections
  SET is_active = false
  WHERE user_id = p_user_id;

  -- Set the specified collection as active
  UPDATE user_collections
  SET is_active = true
  WHERE user_id = p_user_id AND collection_id = p_collection_id;
END;
$$ LANGUAGE plpgsql;
```

## Trading System

### Trading Match Functions

RPC-based trading system for finding mutual matches between users without precomputed tables.

#### Find Mutual Traders Function

```sql
-- Find users who have stickers I want AND want stickers I have
CREATE OR REPLACE FUNCTION find_mutual_traders(
  p_user_id UUID,
  p_collection_id INTEGER,
  p_rarity TEXT DEFAULT NULL,
  p_team TEXT DEFAULT NULL,
  p_query TEXT DEFAULT NULL,
  p_min_overlap INTEGER DEFAULT 1,
  p_limit INTEGER DEFAULT 20,
  p_offset INTEGER DEFAULT 0
) RETURNS TABLE (
  match_user_id UUID,
  nickname TEXT,
  overlap_from_them_to_me BIGINT,
  overlap_from_me_to_them BIGINT,
  total_mutual_overlap BIGINT
) AS $$
BEGIN
  RETURN QUERY
  WITH
  -- Stickers I want (wanted=true, count=0)
  my_wants AS (
    SELECT s.id, s.rarity, s.player_name, s.team_id
    FROM user_stickers us
    JOIN stickers s ON s.id = us.sticker_id
    LEFT JOIN collection_teams ct ON ct.id = s.team_id
    WHERE us.user_id = p_user_id
      AND s.collection_id = p_collection_id
      AND us.wanted = true
      AND us.count = 0
      AND (p_rarity IS NULL OR s.rarity = p_rarity)
      AND (p_team IS NULL OR ct.team_name ILIKE '%' || p_team || '%')
      AND (p_query IS NULL OR s.player_name ILIKE '%' || p_query || '%')
  ),
  -- Stickers I have (count > 0)
  my_have AS (
    SELECT s.id, s.rarity, s.player_name, s.team_id
    FROM user_stickers us
    JOIN stickers s ON s.id = us.sticker_id
    LEFT JOIN collection_teams ct ON ct.id = s.team_id
    WHERE us.user_id = p_user_id
      AND s.collection_id = p_collection_id
      AND us.count > 0
      AND (p_rarity IS NULL OR s.rarity = p_rarity)
      AND (p_team IS NULL OR ct.team_name ILIKE '%' || p_team || '%')
      AND (p_query IS NULL OR s.player_name ILIKE '%' || p_query || '%')
  ),
  -- Find overlaps
  mutual_matches AS (
    SELECT
      other_users.user_id as match_user_id,
      COUNT(DISTINCT they_have.sticker_id) as they_offer_count,
      COUNT(DISTINCT they_want.sticker_id) as they_want_count
    FROM (
      -- Users who have stickers I want
      SELECT DISTINCT us.user_id
      FROM user_stickers us
      JOIN my_wants mw ON mw.id = us.sticker_id
      WHERE us.user_id != p_user_id
        AND us.count > 0

      INTERSECT

      -- Users who want stickers I have
      SELECT DISTINCT us.user_id
      FROM user_stickers us
      JOIN my_have mh ON mh.id = us.sticker_id
      WHERE us.user_id != p_user_id
        AND us.wanted = true
        AND us.count = 0
    ) other_users
    -- Calculate what they can offer me
    LEFT JOIN user_stickers they_have ON (
      they_have.user_id = other_users.user_id
      AND they_have.count > 0
      AND they_have.sticker_id IN (SELECT id FROM my_wants)
    )
    -- Calculate what they want from me
    LEFT JOIN user_stickers they_want ON (
      they_want.user_id = other_users.user_id
      AND they_want.wanted = true
      AND they_want.count = 0
      AND they_want.sticker_id IN (SELECT id FROM my_have)
    )
    GROUP BY other_users.user_id
    HAVING COUNT(DISTINCT they_have.sticker_id) >= p_min_overlap
       AND COUNT(DISTINCT they_want.sticker_id) >= p_min_overlap
  )
  SELECT
    mm.match_user_id,
    COALESCE(p.nickname, 'Usuario') as nickname,
    mm.they_offer_count as overlap_from_them_to_me,
    mm.they_want_count as overlap_from_me_to_them,
    (mm.they_offer_count + mm.they_want_count) as total_mutual_overlap
  FROM mutual_matches AS mm
  INNER JOIN profiles p ON p.id = mm.match_user_id -- Changed to INNER JOIN to ensure user exists
  ORDER BY total_mutual_overlap DESC, mm.match_user_id ASC -- Deterministic sorting
  LIMIT p_limit
  OFFSET p_offset;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### Get Mutual Trade Detail Function

```sql
-- Get detailed sticker lists for a specific trading pair
CREATE OR REPLACE FUNCTION get_mutual_trade_detail(
  p_user_id UUID,
  p_other_user_id UUID,
  p_collection_id INTEGER
) RETURNS TABLE (
  direction TEXT, -- 'they_offer' or 'i_offer'
  sticker_id INTEGER,
  sticker_code TEXT,
  player_name TEXT,
  team_name TEXT,
  rarity TEXT,
  count INTEGER
) AS $$
BEGIN
  RETURN QUERY
  -- What they can offer me (they have, I want)
  SELECT
    'they_offer'::TEXT as direction,
    s.id as sticker_id,
    s.code as sticker_code,
    s.player_name,
    COALESCE(ct.team_name, 'Sin equipo') as team_name,
    s.rarity,
    us_them.count
  FROM user_stickers us_me
  JOIN stickers s ON s.id = us_me.sticker_id
  LEFT JOIN collection_teams ct ON ct.id = s.team_id
  JOIN user_stickers us_them ON us_them.sticker_id = s.id
  WHERE us_me.user_id = p_user_id
    AND us_them.user_id = p_other_user_id
    AND s.collection_id = p_collection_id
    AND us_me.wanted = true
    AND us_me.count = 0
    AND us_them.count > 0

  UNION ALL

  -- What I can offer them (I have, they want)
  SELECT
    'i_offer'::TEXT as direction,
    s.id as sticker_id,
    s.code as sticker_code,
    s.player_name,
    COALESCE(ct.team_name, 'Sin equipo') as team_name,
    s.rarity,
    us_me.count
  FROM user_stickers us_them
  JOIN stickers s ON s.id = us_them.sticker_id
  LEFT JOIN collection_teams ct ON ct.id = s.team_id
  JOIN user_stickers us_me ON us_me.sticker_id = s.id
  WHERE us_them.user_id = p_other_user_id
    AND us_me.user_id = p_user_id
    AND s.collection_id = p_collection_id
    AND us_them.wanted = true
    AND us_them.count = 0
    AND us_me.count > 0

  ORDER BY direction, sticker_code;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### Performance Indexes

Indexes required for efficient trading queries:

```sql
-- Composite index for user_stickers filtering
CREATE INDEX IF NOT EXISTS idx_user_stickers_trading
ON user_stickers (sticker_id, user_id, wanted, count);

-- Index for stickers filtering by collection and properties
CREATE INDEX IF NOT EXISTS idx_stickers_collection_filters
ON stickers (collection_id, rarity, team_id, player_name);

-- Index for collection_teams name filtering
CREATE INDEX IF NOT EXISTS idx_collection_teams_name
ON collection_teams (team_name);

-- Index for efficient user lookups in profiles
CREATE INDEX IF NOT EXISTS idx_profiles_nickname
ON profiles (nickname) WHERE nickname IS NOT NULL;
```

### Row Level Security (RLS) Policies

Trading functions maintain user privacy through SECURITY DEFINER and controlled data exposure:

```sql
-- Trading functions are SECURITY DEFINER and only expose essential data
-- No additional RLS policies needed as functions handle access control internally
-- Existing policies on profiles, user_stickers, etc. remain unchanged

-- Ensure functions can only be called by authenticated users
GRANT EXECUTE ON FUNCTION find_mutual_traders TO authenticated;
GRANT EXECUTE ON FUNCTION get_mutual_trade_detail TO authenticated;
```

### Migration Notes

#### Deployment Steps

1. **Create Indexes First** (can be done during low traffic):

   ```sql
   CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_user_stickers_trading
   ON user_stickers (sticker_id, user_id, wanted, count);

   CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_stickers_collection_filters
   ON stickers (collection_id, rarity, team_id, player_name);

   CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_collection_teams_name
   ON collection_teams (team_name);

   CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_profiles_nickname
   ON profiles (nickname) WHERE nickname IS NOT NULL;
   ```

2. **Deploy Functions** (minimal impact):

   ```sql
   -- Copy and execute find_mutual_traders function
   -- Copy and execute get_mutual_trade_detail function
   ```

3. **Grant Permissions**:
   ```sql
   GRANT EXECUTE ON FUNCTION find_mutual_traders TO authenticated;
   GRANT EXECUTE ON FUNCTION get_mutual_trade_detail TO authenticated;
   ```

#### Performance Considerations

- **Query Complexity**: The mutual matching queries involve multiple joins and subqueries. Monitor execution times as user base grows.
- **Pagination**: Always use LIMIT and OFFSET to prevent large result sets.
- **Filter Early**: The functions apply filters at the earliest possible stage to minimize data processing.

#### Caveats

- **Case Sensitivity**: Team and player name searches use ILIKE for case-insensitive matching.
- **Privacy**: Functions only expose essential data (nickname, counts) and never expose private user information.
- **Deterministic Sorting**: Secondary sort by user_id ensures consistent pagination results.

### Future Optimization Notes

```sql
-- Future Optimization: Materialized View for Popular Collections
-- CREATE MATERIALIZED VIEW trading_matches_cache AS
-- SELECT user_id, other_user_id, collection_id,
--        overlap_count, last_updated
-- FROM precomputed_matches
-- WHERE last_updated > NOW() - INTERVAL '1 hour';
--
-- Refresh strategy:
-- - Hourly for active collections
-- - On-demand when user updates their stickers
-- - Background job for less active collections

-- Future Optimization: Caching Layer
-- Consider Redis/Memcached for frequently accessed matches
-- Cache key pattern: "matches:{user_id}:{collection_id}:{filters_hash}"
-- TTL: 15-30 minutes depending on collection activity
```

## Updated RLS Policies

```sql
-- Allow users to manage their own collections
CREATE POLICY "Users can manage their own collections" ON user_collections
FOR ALL USING (auth.uid() = user_id);

-- Allow users to manage their own stickers
CREATE POLICY "Users can manage their own stickers" ON user_stickers
FOR ALL USING (auth.uid() = user_id);
```

## Migration Notes

When implementing these changes:

1. **Add unique constraints** to prevent duplicate collection joins
2. **Create database functions** for complex operations
3. **Test cascade delete behavior** thoroughly
4. **Update RLS policies** if needed
5. **Verify data integrity** after migrations
6. **Deploy trading indexes** before functions to ensure optimal performance
7. **Test trading functions** with sample data before enabling UI


