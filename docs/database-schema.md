# Database Schema Documentation

## Current State: v1.4.4 (Trade Finalization & Notifications)

Last updated: 2025-10-08
Source: Direct export from Supabase production database

## Overview

The CambioCromos database consists of 15 tables supporting:

- User authentication and profiles
- Multi-collection sticker management
- Album-style page navigation (v1.3.0)
- Complete trading proposal system
- Trade history and chat
- Trade finalization handshake (v1.4.4)
- Notifications system (v1.4.4)
- User badges and achievements

---

## Core Tables

### `profiles`

User profiles extending Supabase Auth.

```sql
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  nickname TEXT,
  avatar_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Indexes:**

- Primary key on `id`

**RLS Policies:**

- Users can read all profiles
- Users can only update their own profile

---

### `collections`

Sticker collections (e.g., "UEFA Euro 2024", "Liga 2024/25").

```sql
CREATE TABLE collections (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  name TEXT NOT NULL,
  competition TEXT NOT NULL,
  year TEXT NOT NULL,
  description TEXT,
  image_url TEXT,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Indexes:**

- Primary key on `id`
- `idx_collections_active` on `(is_active)`

**RLS Policies:**

- Public read access
- Admin-only write access

---

### `collection_teams`

Teams within each collection.

```sql
CREATE TABLE collection_teams (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER REFERENCES collections(id) ON DELETE CASCADE,
  team_name TEXT NOT NULL,
  team_code TEXT,
  logo_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Indexes:**

- Primary key on `id`
- `idx_collection_teams_collection` on `(collection_id)`
- `idx_collection_teams_name` on `(team_name)` for trading queries

**RLS Policies:**

- Public read access
- Admin-only write access

---

### `stickers`

Individual stickers within collections.

```sql
CREATE TABLE stickers (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER REFERENCES collections(id) ON DELETE CASCADE,
  team_id INTEGER REFERENCES collection_teams(id) ON DELETE SET NULL,
  code TEXT NOT NULL,
  player_name TEXT NOT NULL,
  position TEXT,
  nationality TEXT,
  rating INTEGER,
  rarity TEXT CHECK (rarity IN ('common', 'rare', 'epic', 'legendary')),
  image_url TEXT,
  sticker_number INTEGER,
  image_path_webp_300 TEXT,
  thumb_path_webp_100 TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),

  CONSTRAINT unique_sticker_code UNIQUE (collection_id, code)
);
```

**New in v1.3.0:**

- `sticker_number`: Unique sequential number within collection
- `image_path_webp_300`: Path to full-size WebP image in Supabase Storage
- `thumb_path_webp_100`: Path to 100px thumbnail in Supabase Storage

**Indexes:**

- Primary key on `id`
- `idx_stickers_collection` on `(collection_id)`
- `idx_stickers_collection_filters` on `(collection_id, rarity, team_id, player_name)` for trading
- `idx_stickers_collection_number_unique` (partial) on `(collection_id, sticker_number)` WHERE `sticker_number IS NOT NULL`

**RLS Policies:**

- Public read access
- Admin-only write access

---

### `user_collections`

Tracks which collections users have joined and which is active.

```sql
CREATE TABLE user_collections (
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  collection_id INTEGER REFERENCES collections(id) ON DELETE CASCADE,
  is_active BOOLEAN DEFAULT false,
  joined_at TIMESTAMPTZ DEFAULT NOW(),

  PRIMARY KEY (user_id, collection_id),
  CONSTRAINT unique_active_per_user
    UNIQUE (user_id, is_active)
    WHERE (is_active = true)
);
```

**Constraints:**

- Only one active collection per user (partial unique constraint)

**Indexes:**

- Primary key on `(user_id, collection_id)`

**RLS Policies:**

- Users can only access their own collection memberships



---

### `user_stickers`

User's sticker inventory.

```sql
CREATE TABLE user_stickers (
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  sticker_id INTEGER REFERENCES stickers(id) ON DELETE CASCADE,
  count INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  PRIMARY KEY (user_id, sticker_id)
);
```

**Indexes:**

- Primary key on `(user_id, sticker_id)`
- `idx_user_stickers_trading_v2` on `(sticker_id, user_id, count)` for duplicate-driven trading queries
- `idx_user_stickers_user_collection_sticker` on `(user_id, collection_id, sticker_id)` for fast user inventory lookups
- `idx_user_stickers_user_collection_sticker_count` on `(user_id, collection_id, sticker_id, count)` for filtering by count

**RLS Policies:**

- Users can only access their own sticker inventory

**Notes:**

- Trade intent is derived from `count` values (missing = 0, duplicates > 1).
- Legacy `wanted` flag removed in v1.4.0.

---

## Album Pages System (v1.3.0)

### `collection_pages`

Defines pages within an album (team rosters, special cards sections).

```sql
CREATE TABLE collection_pages (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER NOT NULL REFERENCES collections(id) ON DELETE CASCADE,
  kind TEXT NOT NULL CHECK (kind IN ('team', 'special')),
  team_id INTEGER REFERENCES collection_teams(id) ON DELETE SET NULL,
  title TEXT NOT NULL,
  order_index INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT collection_pages_kind_team_check
    CHECK ((kind = 'team' AND team_id IS NOT NULL) OR
           (kind = 'special' AND team_id IS NULL))
);
```

**Design:**

- `kind = 'team'`: Team roster page (20 slots: badge, manager, 18 players)
- `kind = 'special'`: Special cards page (variable slots)
- `order_index`: Sort order for page navigation

**Indexes:**

- Primary key on `id`
- `idx_collection_pages_order` on `(collection_id, order_index)`
- `idx_collection_pages_page_collection` on `(page_id, collection_id)` for page validation _(v1.4.0)_
- `idx_collection_pages_collection` on `(collection_id)` for collection lookups _(v1.4.0)_

**RLS Policies:**

- Public read access
- No client writes allowed

---

### `page_slots`

Maps stickers to specific positions on album pages.

```sql
CREATE TABLE page_slots (
  page_id BIGINT NOT NULL REFERENCES collection_pages(id) ON DELETE CASCADE,
  slot_index INTEGER NOT NULL,
  sticker_id INTEGER REFERENCES stickers(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  PRIMARY KEY (page_id, slot_index)
);
```

**Design:**

- `slot_index`: 0-based position on page
- For team pages: 0 = badge, 1 = manager, 2-19 = players
- For special pages: variable based on content

**Indexes:**

- Primary key on `(page_id, slot_index)`
- `idx_page_slots_page_slot` on `(page_id, slot_index)` (covering index)
- `idx_page_slots_page_id` on `(page_id)` for page→stickers lookups
- `idx_page_slots_page_sticker` on `(page_id, sticker_id)` composite for joins

**RLS Policies:**

- Public read access
- No client writes allowed

---

## Trading System

### `trade_proposals`

Trade proposals between users.

```sql
CREATE TABLE trade_proposals (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER NOT NULL REFERENCES collections(id) ON DELETE CASCADE,
  from_user UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  to_user UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'accepted', 'rejected', 'cancelled')),
  message TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Status Flow:**

- `pending`: Awaiting recipient response
- `accepted`: Recipient accepted the trade
- `rejected`: Recipient rejected the trade
- `cancelled`: Sender cancelled before response

**Indexes:**

- Primary key on `id`
- `idx_trade_proposals_from_user` on `(from_user, status)`
- `idx_trade_proposals_to_user` on `(to_user, status)`
- `idx_trade_proposals_status` on `(status)`

**RLS Policies:**

- Users can only see proposals where they are sender or receiver
- No direct INSERT/UPDATE/DELETE (must use RPC functions)

---

### `trade_proposal_items`

Individual stickers in each proposal (offer or request).

```sql
CREATE TABLE trade_proposal_items (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  proposal_id BIGINT NOT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  sticker_id INTEGER NOT NULL REFERENCES stickers(id) ON DELETE CASCADE,
  count INTEGER NOT NULL CHECK (count > 0),
  direction TEXT NOT NULL CHECK (direction IN ('offer', 'request')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Design:**

- `direction = 'offer'`: Stickers the sender is offering
- `direction = 'request'`: Stickers the sender is requesting

**Indexes:**

- Primary key on `id`
- `idx_trade_proposal_items_proposal` on `(proposal_id)`

**RLS Policies:**

- Access controlled through parent `trade_proposals` table

---

### `trade_chats`

Chat messages within trade proposals.

```sql
CREATE TABLE trade_chats (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  trade_id BIGINT NOT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  sender_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  message TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Indexes:**

- Primary key on `id`
- `idx_trade_chats_trade_created_at` on `(trade_id, created_at)` for chronological loading

**RLS Policies:**

- Only proposal participants can read/write messages
- Messages are immutable once created

---

### `trade_reads` ✅ **v1.4.2 NEW**

Tracks last read timestamp for each user per trade (for unread message badges).

```sql
CREATE TABLE trade_reads (
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  trade_id BIGINT NOT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  last_read_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  PRIMARY KEY (user_id, trade_id)
);
```

**Design:**

- `user_id`: User who read the trade
- `trade_id`: Trade proposal ID
- `last_read_at`: Timestamp of last read action

**Indexes:**

- Primary key on `(user_id, trade_id)`
- `idx_trade_reads_user_id` on `(user_id)` for user lookups
- `idx_trade_reads_trade_id` on `(trade_id)` for trade lookups

**RLS Policies:**

- Owner-only access: `user_id = auth.uid()` for SELECT, INSERT, UPDATE, DELETE
- Users can only read/modify their own read timestamps

**Usage:**

- Upserted via `mark_trade_read(p_trade_id)` RPC when user opens chat
- Queried via `get_unread_counts(p_box, p_trade_ids)` RPC for badge counts

---

### `trades_history`

Terminal state tracking for completed/cancelled trades.

```sql
CREATE TABLE trades_history (
  trade_id BIGINT PRIMARY KEY REFERENCES trade_proposals(id) ON DELETE CASCADE,
  status TEXT NOT NULL CHECK (status IN ('completed', 'cancelled')),
  completed_at TIMESTAMPTZ,
  cancelled_at TIMESTAMPTZ,
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb
);
```

**Design:**

- Single row per trade once it reaches terminal state
- `metadata`: Reserved for audit trails, ratings, etc.

**Indexes:**

- Primary key on `trade_id`

**RLS Policies:**

- Only proposal participants can read history

---

### `trade_finalizations` _(v1.4.4)_

Two-step handshake for trade completion.

```sql
CREATE TABLE trade_finalizations (
  trade_id BIGINT NOT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  finalized_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  PRIMARY KEY (trade_id, user_id)
);
```

**Design:**

- Composite PK ensures each user can only finalize once per trade
- Both participants must finalize before trade moves to `trades_history`
- `finalized_at`: Timestamp when user confirmed finalization

**Indexes:**

- Primary key on `(trade_id, user_id)`
- `idx_trade_finalizations_trade_id` on `(trade_id)` for counting participants

**RLS Policies:**

- Only proposal participants can read finalization status
- Users can only insert their own finalization records
- No updates or deletes allowed (immutable once created)

**Usage:**

- Insert via `mark_trade_finalized(p_trade_id)` RPC
- RPC returns `both_finalized` boolean
- When both finalized, trade automatically moves to `trades_history` with status 'completed'

---

### `notifications` _(v1.4.4)_

User notifications for chat messages, proposal status changes, and finalization requests.

```sql
CREATE TABLE notifications (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  kind TEXT NOT NULL CHECK (kind IN ('chat_unread', 'proposal_accepted', 'proposal_rejected', 'finalization_requested')),
  trade_id BIGINT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  read_at TIMESTAMPTZ NULL,
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb
);
```

**Design:**

- `kind`: Notification type (4 types for MVP)
  - `chat_unread`: Unread chat messages (coalesced per trade)
  - `proposal_accepted`: Proposal was accepted
  - `proposal_rejected`: Proposal was rejected
  - `finalization_requested`: Counterparty requested finalization
- `trade_id`: Associated trade (NULL for system notifications)
- `read_at`: NULL for unread, timestamp when marked read
- `metadata`: JSON blob for additional data (e.g., last_message_id, requester_id)

**Indexes:**

- Primary key on `id`
- `idx_notifications_user_read` on `(user_id, read_at)` for unread queries
- `idx_notifications_user_kind_read` on `(user_id, kind, read_at)` for filtering by type
- `idx_notifications_user_trade_kind_read` on `(user_id, trade_id, kind, read_at)` for trade-specific queries
- `idx_notifications_trade_id` on `(trade_id)` for trade lookups
- `idx_notifications_user_trade_kind_unread_unique` (UNIQUE partial index) on `(user_id, trade_id, kind)` WHERE `kind = 'chat_unread' AND read_at IS NULL` for chat notification coalescing

**RLS Policies:**

- Users can only see their own notifications (`user_id = auth.uid()`)
- Users can only insert their own notifications (for RPC/trigger usage)
- Users can only update/delete their own notifications

**Triggers:**

- `trigger_notify_chat_message`: Creates/updates `chat_unread` notification when new chat message is inserted
- `trigger_notify_proposal_status_change`: Creates notification when proposal status changes to `accepted` or `rejected`
- `trigger_notify_finalization_requested`: Creates notification when counterparty marks trade as finalized

**Usage:**

- Query via `get_notifications()` RPC (returns enriched data with trade details)
- Count via `get_notification_count()` RPC (returns unread count)
- Mark all read via `mark_all_notifications_read()` RPC

---

## Badges & Achievements (v1.3.0)

### `user_badges`

User achievement badges.

```sql
CREATE TABLE user_badges (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  badge_code TEXT NOT NULL,
  awarded_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT user_badges_user_code_unique UNIQUE (user_id, badge_code)
);
```

**Design:**

- Service-managed (no direct client writes)
- `badge_code`: Unique identifier for badge type

**Indexes:**

- Primary key on `id`
- Unique constraint on `(user_id, badge_code)`

**RLS Policies:**

- Users can only read their own badges
- No client writes allowed

---

## Database Functions (RPCs)

### Collection Statistics

#### `get_user_collection_stats`

Returns completion statistics for a user's collection. Missing counts are inferred from ownership records (count = 0).

```sql
FUNCTION get_user_collection_stats(
  p_user_id UUID,
  p_collection_id INTEGER
) RETURNS JSON
```

**Returns:**

```json
{
  "total_stickers": 600,
  "owned_stickers": 450,
  "completion_percentage": 75,
  "duplicates": 120,
  "missing": 150,
}
```

**Security:** SECURITY DEFINER

---

#### `get_completion_report` _(v1.3.0)_

Generates per-page completion report.

```sql
FUNCTION get_completion_report(
  p_user_id UUID,
  p_collection_id INTEGER
) RETURNS JSON
```

**Returns:**

```json
{
  "collection_id": 1,
  "pages": [
    {
      "page_id": 1,
      "title": "FC Barcelona",
      "kind": "team",
      "order_index": 1,
      "missing": [1, 5, 12],
      "repes": [3, 7, 15]
    }
  ]
}
```

**Security:** SECURITY DEFINER, requires caller = `p_user_id`

---

### Sticker Management

#### `bulk_add_stickers_by_numbers` _(v1.3.0)_

Add multiple stickers by their numbers in one operation.

```sql
FUNCTION bulk_add_stickers_by_numbers(
  p_user_id UUID,
  p_collection_id INTEGER,
  p_numbers INTEGER[]
) RETURNS JSON
```

**Returns:**

```json
{
  "added": 5,
  "duplicates": [12, 15],
  "invalid": [999]
}
```

**Security:** SECURITY DEFINER, requires caller = `p_user_id`

---

#### `search_stickers` _(v1.3.0)_

Search stickers with filters and ownership status.

```sql
FUNCTION search_stickers(
  p_collection_id INTEGER,
  p_query TEXT,
  p_filters JSONB
) RETURNS SETOF sticker_search_result
```

**Filters:**

```json
{
  "owned": true,
  "missing": false,
  "repes": true,
  "kind": "team"
}
```

**Security:** SECURITY DEFINER, authenticated users only

---

### Trading - Discovery

#### `find_mutual_traders`

Find users with mutual trading opportunities. Sticker intent is inferred from inventory counts: a sticker is missing when the seeker has `count = 0`, and a tradeable duplicate is available when the owner has `count > 1`.

```sql
FUNCTION find_mutual_traders(
  p_user_id UUID,
  p_collection_id INTEGER,
  p_rarity TEXT DEFAULT NULL,
  p_team TEXT DEFAULT NULL,
  p_query TEXT DEFAULT NULL,
  p_min_overlap INTEGER DEFAULT 1,
  p_limit INTEGER DEFAULT 20,
  p_offset INTEGER DEFAULT 0
) RETURNS TABLE (
  match_user_id UUID,
  nickname TEXT,
  overlap_from_them_to_me BIGINT,
  overlap_from_me_to_them BIGINT,
  total_mutual_overlap BIGINT
)
```

**Security:** SECURITY DEFINER

---

#### `get_mutual_trade_detail`

Get detailed sticker lists for a trading pair. Rows are emitted with `direction = 'they_offer'` when the other user has duplicates (`count > 1`) and the current user has none (`count = 0`), and `direction = 'i_offer'` for the inverse.

```sql
FUNCTION get_mutual_trade_detail(
  p_user_id UUID,
  p_other_user_id UUID,
  p_collection_id INTEGER
) RETURNS TABLE (
  direction TEXT,
  sticker_id INTEGER,
  sticker_code TEXT,
  player_name TEXT,
  team_name TEXT,
  rarity TEXT,
  count INTEGER
)
```

**Security:** SECURITY DEFINER

---

### Trading - Proposals

#### `create_trade_proposal`

Create a new trade proposal. The message is stored as the first chat message, not in the proposal record.

```sql
FUNCTION create_trade_proposal(
  p_collection_id INTEGER,
  p_to_user UUID,
  p_offer_items proposal_item[],
  p_request_items proposal_item[],
  p_message TEXT
) RETURNS BIGINT
```

**Parameters:**
- `p_collection_id`: The collection ID for the trade
- `p_to_user`: UUID of the user receiving the proposal
- `p_offer_items`: Array of items the sender is offering
- `p_request_items`: Array of items the sender is requesting
- `p_message`: Optional message (stored as first chat message if provided)

**Returns:** The proposal ID (BIGINT)

**Behavior:**
- Creates a trade proposal with status 'pending'
- Inserts offer and request items into trade_proposal_items
- If a message is provided, inserts it as the first message in trade_chats
- The proposal.message field is always NULL (messages go to trade_chats)

**Security:** SECURITY DEFINER

---

#### `respond_to_trade_proposal`

Accept, reject, or cancel a proposal.

```sql
FUNCTION respond_to_trade_proposal(
  p_proposal_id INTEGER,
  p_action TEXT
) RETURNS JSON
```

**Actions:** `'accept'`, `'reject'`, `'cancel'`

**Security:** SECURITY DEFINER

---

#### `list_trade_proposals`

List inbox or outbox proposals.

```sql
FUNCTION list_trade_proposals(
  p_user_id UUID,
  p_box TEXT,
  p_limit INTEGER DEFAULT 20,
  p_offset INTEGER DEFAULT 0
) RETURNS TABLE (...)
```

**Box:** `'inbox'` or `'outbox'`

**Security:** SECURITY DEFINER

---

#### `get_trade_proposal_detail`

Get complete proposal details.

```sql
FUNCTION get_trade_proposal_detail(
  p_proposal_id INTEGER
) RETURNS JSON
```

**Security:** SECURITY DEFINER

---

### Trading - History

#### `complete_trade` _(v1.3.0)_

Mark a trade as completed.

```sql
FUNCTION complete_trade(
  p_trade_id BIGINT
) RETURNS VOID
```

**Security:** SECURITY DEFINER, only participants

---

#### `cancel_trade` _(v1.3.0)_

Cancel a trade.

```sql
FUNCTION cancel_trade(
  p_trade_id BIGINT
) RETURNS VOID
```

**Security:** SECURITY DEFINER, only participants

---

### Trading - Chat & Unread Badges ✅ **v1.4.2 NEW**

#### `mark_trade_read`

Mark a trade as read for the current user (upserts last_read_at timestamp).

```sql
FUNCTION mark_trade_read(
  p_trade_id BIGINT
) RETURNS VOID
```

**Parameters:**

- `p_trade_id`: Trade proposal ID (required)

**Behavior:**

- Automatically uses `auth.uid()` for user_id (SECURITY DEFINER)
- Upserts `trade_reads` row with `last_read_at = NOW()`
- Validates user is a participant in the trade
- Raises exception if not authenticated or not a participant

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { error } = await supabase.rpc('mark_trade_read', {
  p_trade_id: tradeId,
});

if (error) {
  console.error('Error marking trade as read:', error);
}
```

---

#### `get_unread_counts`

Returns unread message counts per trade for the current user in the specified box.

```sql
FUNCTION get_unread_counts(
  p_box TEXT,
  p_trade_ids INT8[] DEFAULT NULL
) RETURNS TABLE (
  trade_id BIGINT,
  unread_count BIGINT
)
```

**Parameters:**

- `p_box`: Box to query (`'inbox'` or `'outbox'`) (required)
- `p_trade_ids`: Optional array of trade IDs to filter by (for pagination)

**Returns:**

Array of objects with:
- `trade_id`: Trade proposal ID
- `unread_count`: Number of unread messages from counterparty

**Behavior:**

- Automatically scopes to `auth.uid()` (SECURITY DEFINER)
- Filters trades by box:
  - `inbox`: trades where `to_user = auth.uid()`
  - `outbox`: trades where `from_user = auth.uid()`
- Counts messages from counterparty (`sender_id <> auth.uid()`) where `created_at > COALESCE(last_read_at, 'epoch')`
- Returns 0 for trades with no unread messages
- If `p_trade_ids` provided, only returns counts for those trades

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { data, error } = await supabase.rpc('get_unread_counts', {
  p_box: 'inbox',
  p_trade_ids: [123, 456, 789], // Optional
});

if (error) throw error;

// data = [{ trade_id: 123, unread_count: 5 }, { trade_id: 456, unread_count: 0 }, ...]
const unreadMap = new Map(data.map(item => [item.trade_id, item.unread_count]));
```

---

### Sticker Completion

#### `mark_team_page_complete` _(v1.4.0)_

Marks all stickers on a team page as owned (count=1) for a user. Only adds stickers that are currently missing (no row or count=0). Idempotent - returns added_count=0 if page already complete.

```sql
FUNCTION mark_team_page_complete(
  p_user_id UUID,
  p_collection_id INT,
  p_page_id INT
) RETURNS JSONB
```

**Parameters:**

- `p_user_id`: User UUID (must match authenticated user)
- `p_collection_id`: Collection ID that owns the page
- `p_page_id`: Page ID to mark complete (must be a team page)

**Returns:**

```json
{
  "added_count": 5,
  "affected_sticker_ids": [1, 5, 12, 18, 20]
}
```

**Preconditions:**

- User must be authenticated (`auth.uid()`)
- Caller must be acting on their own behalf (`p_user_id = auth.uid()`)
- Page must belong to the specified collection
- Page must be a team page (`kind = 'team'` or exactly 20 slots)

**Side Effects:**

- Inserts new rows into `user_stickers` with `count = 1` for missing stickers
- Updates existing rows where `count = 0` to `count = 1`
- Does NOT modify stickers with `count >= 1` (preserves singles and duplicates)
- Idempotent: re-running on same page returns `added_count = 0`

**Security:**

- `SECURITY DEFINER`: Runs with elevated privileges
- Auth guard: Validates `p_user_id = auth.uid()` at function start
- RLS remains enabled on `user_stickers` table
- Cross-user writes blocked by exception

**Scope:**

- **Team pages only**: Badge + manager + 18 players (20 slots)
- **Special pages**: Not supported in Phase 1 (raises exception)

**Error Cases:**

- Cross-user write: `Unauthorized: Cannot modify stickers for another user`
- Invalid page/collection: `Invalid page_id X for collection_id Y`
- Non-team page: `Only team pages are supported` (SQLSTATE `check_violation`)
- RLS violations: Standard Supabase RLS errors

**Full Implementation:**

```sql
-- Drop existing function if it exists
DROP FUNCTION IF EXISTS mark_team_page_complete(UUID, INT, INT);

-- Create the function with team page validation
CREATE OR REPLACE FUNCTION mark_team_page_complete(
    p_user_id UUID,
    p_collection_id INT,
    p_page_id INT
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO public
AS $$
DECLARE
    v_added_count INT := 0;
    v_affected_sticker_ids INT[] := ARRAY[]::INT[];
    v_page_exists BOOLEAN;
    v_page_kind TEXT;
    v_slot_count INT;
BEGIN
    -- Security: Verify the caller is acting on their own behalf
    IF p_user_id <> auth.uid() THEN
        RAISE EXCEPTION 'Unauthorized: Cannot modify stickers for another user';
    END IF;

    -- Validate that the page belongs to the collection and get page kind
    SELECT
        EXISTS(
            SELECT 1
            FROM collection_pages
            WHERE id = p_page_id
              AND collection_id = p_collection_id
        ),
        (SELECT kind FROM collection_pages WHERE id = p_page_id)
    INTO v_page_exists, v_page_kind;

    IF NOT v_page_exists THEN
        RAISE EXCEPTION 'Invalid page_id % for collection_id %', p_page_id, p_collection_id;
    END IF;

    -- Guard: Only allow team pages
    -- First try to use collection_pages.kind if available
    IF v_page_kind IS NOT NULL THEN
        -- Column exists, use it directly
        IF v_page_kind <> 'team' THEN
            RAISE EXCEPTION 'Only team pages are supported'
                USING ERRCODE = 'check_violation';
        END IF;
    ELSE
        -- Fallback: check slot count (team pages have exactly 20 slots)
        SELECT COUNT(*)
        INTO v_slot_count
        FROM page_slots
        WHERE page_id = p_page_id;

        IF v_slot_count <> 20 THEN
            RAISE EXCEPTION 'Only team pages are supported'
                USING ERRCODE = 'check_violation';
        END IF;
    END IF;

    -- Insert missing stickers (count = 0 or no row) and collect affected IDs
    WITH page_stickers AS (
        -- Get all stickers on this page that belong to the collection
        SELECT ps.sticker_id
        FROM page_slots ps
        INNER JOIN stickers s ON s.id = ps.sticker_id
        WHERE ps.page_id = p_page_id
          AND s.collection_id = p_collection_id
    ),
    missing_stickers AS (
        -- Find stickers that are missing (no row or count = 0)
        SELECT ps.sticker_id
        FROM page_stickers ps
        LEFT JOIN user_stickers us ON
            us.user_id = p_user_id
            AND us.sticker_id = ps.sticker_id
        WHERE us.sticker_id IS NULL OR us.count = 0
    ),
    inserted AS (
        -- Upsert: insert new rows or update count to 1 where it was 0
        INSERT INTO user_stickers (user_id, sticker_id, count)
        SELECT p_user_id, sticker_id, 1
        FROM missing_stickers
        ON CONFLICT (user_id, sticker_id)
        DO UPDATE SET count = 1
        WHERE user_stickers.count = 0
        RETURNING sticker_id
    )
    SELECT
        COUNT(*)::INT,
        ARRAY_AGG(sticker_id ORDER BY sticker_id)
    INTO v_added_count, v_affected_sticker_ids
    FROM inserted;

    -- Handle case where no stickers were added
    IF v_affected_sticker_ids IS NULL THEN
        v_affected_sticker_ids := ARRAY[]::INT[];
    END IF;

    RETURN jsonb_build_object(
        'added_count', v_added_count,
        'affected_sticker_ids', v_affected_sticker_ids
    );
END;
$$;

-- Revoke all permissions from public
REVOKE ALL ON FUNCTION mark_team_page_complete(UUID, INT, INT) FROM PUBLIC;

-- Grant execute to authenticated users
GRANT EXECUTE ON FUNCTION mark_team_page_complete(UUID, INT, INT) TO authenticated;

-- Add function comment
COMMENT ON FUNCTION mark_team_page_complete(UUID, INT, INT) IS
'Marks all stickers on a team page as owned (count=1) for a user. Only adds stickers that are currently missing (no row or count=0). Idempotent - returns added_count=0 if page already complete. Only supports team pages (kind=team or exactly 20 slots).';
```

---

## Triggers

### `handle_updated_at`

Automatically updates `updated_at` column on row modifications.

Applied to:

- `profiles`
- `user_stickers`
- `trade_proposals`

---

## Supabase Storage Buckets

### `sticker-images`

Stores sticker artwork.

**Structure:**

```
sticker-images/
├── {collection_id}/
│   ├── {sticker_number}-{sticker_id}.webp (300px)
│   └── thumbs/
│       └── {sticker_number}-{sticker_id}.webp (100px)
```

**Configuration:**

- Public read access
- Authenticated write only
- Max file size: 5MB
- Allowed MIME types: `image/webp`, `image/png`, `image/jpeg`

---

### `avatars`

Stores user profile avatars.

**Configuration:**

- Public read access
- Authenticated write only
- Max file size: 2MB
- Allowed MIME types: `image/webp`, `image/png`, `image/jpeg`

---

## Migration Notes

### Deployment Checklist

1. ✅ All core tables created
2. ✅ All indexes applied
3. ✅ All RLS policies active
4. ✅ All RPC functions deployed
5. ✅ Storage buckets configured
6. ⚠️ Backfill `stickers.sticker_number` before enforcing NOT NULL
7. ⚠️ Populate `collection_pages` and `page_slots` for active collections

### Performance Monitoring

Key indexes for monitoring:

- `idx_user_stickers_trading_v2` (Phase 1 high traffic)
- `idx_user_stickers_trading` (kept during transition)
- `idx_stickers_collection_filters` (trading queries)
- `idx_trade_proposals_to_user` (inbox queries)
- `idx_collection_pages_order` (album navigation)
- `idx_page_slots_page_id` (page completion queries - v1.4.0)
- `idx_user_stickers_user_collection_sticker_count` (page completion queries - v1.4.0)

---

## Performance Indexes (v1.4.0)

The following indexes optimize the `mark_team_page_complete` function and related page-based operations:

```sql
-- Indexes for mark_team_page_complete performance
-- These support fast lookups in the function's CTEs

-- Index for page_slots: quick lookup of all stickers on a given page
CREATE INDEX IF NOT EXISTS idx_page_slots_page_id
ON page_slots(page_id);

-- Composite index for page_slots: covers both columns used in joins
CREATE INDEX IF NOT EXISTS idx_page_slots_page_sticker
ON page_slots(page_id, sticker_id);

-- Index for user_stickers: fast lookup by user + collection + sticker
-- This supports the LEFT JOIN in missing_stickers CTE
CREATE INDEX IF NOT EXISTS idx_user_stickers_user_collection_sticker
ON user_stickers(user_id, collection_id, sticker_id);

-- Additional index including count for filtering count = 0
CREATE INDEX IF NOT EXISTS idx_user_stickers_user_collection_sticker_count
ON user_stickers(user_id, collection_id, sticker_id, count);

-- Index for collection_pages: validate page belongs to collection
CREATE INDEX IF NOT EXISTS idx_collection_pages_page_collection
ON collection_pages(page_id, collection_id);

-- Alternative index if collection_pages has 'id' as primary key
CREATE INDEX IF NOT EXISTS idx_collection_pages_collection
ON collection_pages(collection_id);

/*
EXPECTED QUERY PLAN SHAPE:
============================

1. Page validation (collection_pages):
   -> Index Scan using idx_collection_pages_page_collection
   -> Should be instant lookup

2. page_stickers CTE (page_slots):
   -> Index Scan using idx_page_slots_page_id
   -> Returns ~20 rows for team pages

3. missing_stickers CTE (LEFT JOIN):
   -> Nested Loop Left Join
      -> Seq Scan on page_stickers (small CTE, ~20 rows)
      -> Index Scan using idx_user_stickers_user_collection_sticker
   -> Filter on (us.sticker_id IS NULL OR us.count = 0)

4. INSERT with ON CONFLICT:
   -> Uses unique constraint on (user_id, collection_id, sticker_id)
   -> Supported by idx_user_stickers_user_collection_sticker

Overall: Should be < 10ms for typical team page (20 stickers)
Key: All joins use index scans, no table scans except tiny CTEs
*/
```

---

### Trade Finalization _(v1.4.4)_

#### `mark_trade_finalized`

Two-step handshake for trade completion. Both participants must call this function before the trade is marked as completed.

```sql
FUNCTION mark_trade_finalized(
  p_trade_id BIGINT
) RETURNS JSONB
```

**Parameters:**

- `p_trade_id`: Trade proposal ID (required)

**Returns:**

```json
{
  "both_finalized": true,
  "finalized_count": 2
}
```

**Behavior:**

- Automatically uses `auth.uid()` for user_id (SECURITY DEFINER)
- Validates user is a participant in the trade (from_user or to_user)
- Inserts finalization record for current user
- Checks if both participants have finalized
- If both finalized, automatically creates `trades_history` record with status 'completed'
- Idempotent - calling multiple times by same user has no effect
- Raises exception if not authenticated or not a participant

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { data, error } = await supabase.rpc('mark_trade_finalized', {
  p_trade_id: tradeId,
});

if (error) {
  console.error('Error finalizing trade:', error);
  return;
}

if (data.both_finalized) {
  toast.success('¡Intercambio finalizado! Ambos participantes confirmaron.');
  // Close modal, refresh history, etc.
} else {
  toast.success(`Confirmado. Esperando confirmación de la otra parte (${data.finalized_count}/2).`);
}
```

---

### Notifications _(v1.4.4)_

#### `get_notifications`

Returns all notifications for the current user with enriched trade details.

```sql
FUNCTION get_notifications()
RETURNS TABLE (
  id BIGINT,
  kind TEXT,
  trade_id BIGINT,
  created_at TIMESTAMPTZ,
  read_at TIMESTAMPTZ,
  metadata JSONB,
  proposal_from_user UUID,
  proposal_to_user UUID,
  proposal_status TEXT,
  from_user_nickname TEXT,
  to_user_nickname TEXT
)
```

**Returns:**

Array of notification objects with joined trade proposal and profile data:
- `id`: Notification ID
- `kind`: Notification type (chat_unread, proposal_accepted, proposal_rejected, finalization_requested)
- `trade_id`: Associated trade ID
- `created_at`: When notification was created
- `read_at`: When notification was marked read (NULL if unread)
- `metadata`: Additional JSON data
- `proposal_from_user`: UUID of proposal sender
- `proposal_to_user`: UUID of proposal recipient
- `proposal_status`: Current status of trade proposal
- `from_user_nickname`: Sender's nickname
- `to_user_nickname`: Recipient's nickname

**Behavior:**

- Automatically scopes to `auth.uid()` (SECURITY DEFINER)
- Ordered by unread first, then by creation date descending
- Includes LEFT JOIN to trade_proposals and profiles for enriched data

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { data: notifications, error } = await supabase.rpc('get_notifications');

if (error) throw error;

// data is enriched with trade and profile information
```

---

#### `get_notification_count`

Returns count of unread notifications for the current user.

```sql
FUNCTION get_notification_count()
RETURNS INTEGER
```

**Returns:**

Integer count of notifications where `read_at IS NULL`

**Behavior:**

- Automatically scopes to `auth.uid()` (SECURITY DEFINER)
- Fast count query using indexed `read_at` column

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { data: count, error } = await supabase.rpc('get_notification_count');

if (error) throw error;

// Display badge with count
setBadgeCount(count);
```

---

#### `mark_all_notifications_read`

Marks all unread notifications as read for the current user.

```sql
FUNCTION mark_all_notifications_read()
RETURNS VOID
```

**Behavior:**

- Automatically scopes to `auth.uid()` (SECURITY DEFINER)
- Updates all notifications where `read_at IS NULL` to `read_at = NOW()`
- Idempotent - safe to call multiple times

**Security:** SECURITY DEFINER, requires authentication

**Usage Example:**

```typescript
const { error } = await supabase.rpc('mark_all_notifications_read');

if (error) {
  console.error('Error marking notifications as read:', error);
  return;
}

// Refresh notification list
```

---

## Schema Version History

- **v1.4.4** (Current): Trade finalization handshake, notifications system (MVP)
- **v1.4.3**: Trade flow optimization, SegmentedTabs component
- **v1.4.2**: Trade composer UX improvements, trade matching logic fixes
- **v1.4.1**: Complete Retro-Comic theme rollout
- **v1.4.0**: Mark team page complete feature, schema cleanup
- **v1.3.0**: Album pages, trade history, badges, enhanced sticker images
- **v1.2.0**: Complete trade proposals system
- **v1.1.0**: Trading discovery (find mutual traders)
- **v1.0.0**: Core collection and sticker management

---

**Status:** ✅ All v1.4.4 features deployed and documented
**Next:** Realtime notification updates, additional notification types
