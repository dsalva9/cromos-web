# Database Schema Documentation

## Current State: v1.4.0 (Phase 4 schema cleanup)

Last updated: 2025-10-06
Source: Direct export from Supabase production database

## Overview

The CambioCromos database consists of 13 tables supporting:

- User authentication and profiles
- Multi-collection sticker management
- Album-style page navigation (v1.3.0)
- Complete trading proposal system
- Trade history and chat
- User badges and achievements

---

## Core Tables

### `profiles`

User profiles extending Supabase Auth.

```sql
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  nickname TEXT,
  avatar_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Indexes:**

- Primary key on `id`

**RLS Policies:**

- Users can read all profiles
- Users can only update their own profile

---

### `collections`

Sticker collections (e.g., "UEFA Euro 2024", "Liga 2024/25").

```sql
CREATE TABLE collections (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  name TEXT NOT NULL,
  competition TEXT NOT NULL,
  year TEXT NOT NULL,
  description TEXT,
  image_url TEXT,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Indexes:**

- Primary key on `id`
- `idx_collections_active` on `(is_active)`

**RLS Policies:**

- Public read access
- Admin-only write access

---

### `collection_teams`

Teams within each collection.

```sql
CREATE TABLE collection_teams (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER REFERENCES collections(id) ON DELETE CASCADE,
  team_name TEXT NOT NULL,
  team_code TEXT,
  logo_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Indexes:**

- Primary key on `id`
- `idx_collection_teams_collection` on `(collection_id)`
- `idx_collection_teams_name` on `(team_name)` for trading queries

**RLS Policies:**

- Public read access
- Admin-only write access

---

### `stickers`

Individual stickers within collections.

```sql
CREATE TABLE stickers (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER REFERENCES collections(id) ON DELETE CASCADE,
  team_id INTEGER REFERENCES collection_teams(id) ON DELETE SET NULL,
  code TEXT NOT NULL,
  player_name TEXT NOT NULL,
  position TEXT,
  nationality TEXT,
  rating INTEGER,
  rarity TEXT CHECK (rarity IN ('common', 'rare', 'epic', 'legendary')),
  image_url TEXT,
  sticker_number INTEGER,
  image_path_webp_300 TEXT,
  thumb_path_webp_100 TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),

  CONSTRAINT unique_sticker_code UNIQUE (collection_id, code)
);
```

**New in v1.3.0:**

- `sticker_number`: Unique sequential number within collection
- `image_path_webp_300`: Path to full-size WebP image in Supabase Storage
- `thumb_path_webp_100`: Path to 100px thumbnail in Supabase Storage

**Indexes:**

- Primary key on `id`
- `idx_stickers_collection` on `(collection_id)`
- `idx_stickers_collection_filters` on `(collection_id, rarity, team_id, player_name)` for trading
- `idx_stickers_collection_number_unique` (partial) on `(collection_id, sticker_number)` WHERE `sticker_number IS NOT NULL`

**RLS Policies:**

- Public read access
- Admin-only write access

---

### `user_collections`

Tracks which collections users have joined and which is active.

```sql
CREATE TABLE user_collections (
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  collection_id INTEGER REFERENCES collections(id) ON DELETE CASCADE,
  is_active BOOLEAN DEFAULT false,
  joined_at TIMESTAMPTZ DEFAULT NOW(),

  PRIMARY KEY (user_id, collection_id),
  CONSTRAINT unique_active_per_user
    UNIQUE (user_id, is_active)
    WHERE (is_active = true)
);
```

**Constraints:**

- Only one active collection per user (partial unique constraint)

**Indexes:**

- Primary key on `(user_id, collection_id)`

**RLS Policies:**

- Users can only access their own collection memberships



---

### `user_stickers`

User's sticker inventory.

```sql
CREATE TABLE user_stickers (
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  sticker_id INTEGER REFERENCES stickers(id) ON DELETE CASCADE,
  count INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  PRIMARY KEY (user_id, sticker_id)
);
```

**Indexes:**

- Primary key on `(user_id, sticker_id)`
- `idx_user_stickers_trading_v2` on `(sticker_id, user_id, count)` for duplicate-driven trading queries
- `idx_user_stickers_user_collection_sticker` on `(user_id, collection_id, sticker_id)` for fast user inventory lookups
- `idx_user_stickers_user_collection_sticker_count` on `(user_id, collection_id, sticker_id, count)` for filtering by count

**RLS Policies:**

- Users can only access their own sticker inventory

**Notes:**

- Trade intent is derived from `count` values (missing = 0, duplicates > 1).
- Legacy `wanted` flag removed in v1.4.0.

---

## Album Pages System (v1.3.0)

### `collection_pages`

Defines pages within an album (team rosters, special cards sections).

```sql
CREATE TABLE collection_pages (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER NOT NULL REFERENCES collections(id) ON DELETE CASCADE,
  kind TEXT NOT NULL CHECK (kind IN ('team', 'special')),
  team_id INTEGER REFERENCES collection_teams(id) ON DELETE SET NULL,
  title TEXT NOT NULL,
  order_index INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT collection_pages_kind_team_check
    CHECK ((kind = 'team' AND team_id IS NOT NULL) OR
           (kind = 'special' AND team_id IS NULL))
);
```

**Design:**

- `kind = 'team'`: Team roster page (20 slots: badge, manager, 18 players)
- `kind = 'special'`: Special cards page (variable slots)
- `order_index`: Sort order for page navigation

**Indexes:**

- Primary key on `id`
- `idx_collection_pages_order` on `(collection_id, order_index)`
- `idx_collection_pages_page_collection` on `(page_id, collection_id)` for page validation _(v1.4.0)_
- `idx_collection_pages_collection` on `(collection_id)` for collection lookups _(v1.4.0)_

**RLS Policies:**

- Public read access
- No client writes allowed

---

### `page_slots`

Maps stickers to specific positions on album pages.

```sql
CREATE TABLE page_slots (
  page_id BIGINT NOT NULL REFERENCES collection_pages(id) ON DELETE CASCADE,
  slot_index INTEGER NOT NULL,
  sticker_id INTEGER REFERENCES stickers(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  PRIMARY KEY (page_id, slot_index)
);
```

**Design:**

- `slot_index`: 0-based position on page
- For team pages: 0 = badge, 1 = manager, 2-19 = players
- For special pages: variable based on content

**Indexes:**

- Primary key on `(page_id, slot_index)`
- `idx_page_slots_page_slot` on `(page_id, slot_index)` (covering index)
- `idx_page_slots_page_id` on `(page_id)` for page→stickers lookups
- `idx_page_slots_page_sticker` on `(page_id, sticker_id)` composite for joins

**RLS Policies:**

- Public read access
- No client writes allowed

---

## Trading System

### `trade_proposals`

Trade proposals between users.

```sql
CREATE TABLE trade_proposals (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  collection_id INTEGER NOT NULL REFERENCES collections(id) ON DELETE CASCADE,
  from_user UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  to_user UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'accepted', 'rejected', 'cancelled')),
  message TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Status Flow:**

- `pending`: Awaiting recipient response
- `accepted`: Recipient accepted the trade
- `rejected`: Recipient rejected the trade
- `cancelled`: Sender cancelled before response

**Indexes:**

- Primary key on `id`
- `idx_trade_proposals_from_user` on `(from_user, status)`
- `idx_trade_proposals_to_user` on `(to_user, status)`
- `idx_trade_proposals_status` on `(status)`

**RLS Policies:**

- Users can only see proposals where they are sender or receiver
- No direct INSERT/UPDATE/DELETE (must use RPC functions)

---

### `trade_proposal_items`

Individual stickers in each proposal (offer or request).

```sql
CREATE TABLE trade_proposal_items (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  proposal_id BIGINT NOT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  sticker_id INTEGER NOT NULL REFERENCES stickers(id) ON DELETE CASCADE,
  count INTEGER NOT NULL CHECK (count > 0),
  direction TEXT NOT NULL CHECK (direction IN ('offer', 'request')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Design:**

- `direction = 'offer'`: Stickers the sender is offering
- `direction = 'request'`: Stickers the sender is requesting

**Indexes:**

- Primary key on `id`
- `idx_trade_proposal_items_proposal` on `(proposal_id)`

**RLS Policies:**

- Access controlled through parent `trade_proposals` table

---

### `trade_chats`

Chat messages within trade proposals.

```sql
CREATE TABLE trade_chats (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  trade_id BIGINT NOT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
  sender_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  message TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Indexes:**

- Primary key on `id`
- `idx_trade_chats_trade_created_at` on `(trade_id, created_at)` for chronological loading

**RLS Policies:**

- Only proposal participants can read/write messages
- Messages are immutable once created

---

### `trades_history`

Terminal state tracking for completed/cancelled trades.

```sql
CREATE TABLE trades_history (
  trade_id BIGINT PRIMARY KEY REFERENCES trade_proposals(id) ON DELETE CASCADE,
  status TEXT NOT NULL CHECK (status IN ('completed', 'cancelled')),
  completed_at TIMESTAMPTZ,
  cancelled_at TIMESTAMPTZ,
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb
);
```

**Design:**

- Single row per trade once it reaches terminal state
- `metadata`: Reserved for audit trails, ratings, etc.

**Indexes:**

- Primary key on `trade_id`

**RLS Policies:**

- Only proposal participants can read history

---

## Badges & Achievements (v1.3.0)

### `user_badges`

User achievement badges.

```sql
CREATE TABLE user_badges (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  badge_code TEXT NOT NULL,
  awarded_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT user_badges_user_code_unique UNIQUE (user_id, badge_code)
);
```

**Design:**

- Service-managed (no direct client writes)
- `badge_code`: Unique identifier for badge type

**Indexes:**

- Primary key on `id`
- Unique constraint on `(user_id, badge_code)`

**RLS Policies:**

- Users can only read their own badges
- No client writes allowed

---

## Database Functions (RPCs)

### Collection Statistics

#### `get_user_collection_stats`

Returns completion statistics for a user's collection. Missing counts are inferred from ownership records (count = 0).

```sql
FUNCTION get_user_collection_stats(
  p_user_id UUID,
  p_collection_id INTEGER
) RETURNS JSON
```

**Returns:**

```json
{
  "total_stickers": 600,
  "owned_stickers": 450,
  "completion_percentage": 75,
  "duplicates": 120,
  "missing": 150,
}
```

**Security:** SECURITY DEFINER

---

#### `get_completion_report` _(v1.3.0)_

Generates per-page completion report.

```sql
FUNCTION get_completion_report(
  p_user_id UUID,
  p_collection_id INTEGER
) RETURNS JSON
```

**Returns:**

```json
{
  "collection_id": 1,
  "pages": [
    {
      "page_id": 1,
      "title": "FC Barcelona",
      "kind": "team",
      "order_index": 1,
      "missing": [1, 5, 12],
      "repes": [3, 7, 15]
    }
  ]
}
```

**Security:** SECURITY DEFINER, requires caller = `p_user_id`

---

### Sticker Management

#### `bulk_add_stickers_by_numbers` _(v1.3.0)_

Add multiple stickers by their numbers in one operation.

```sql
FUNCTION bulk_add_stickers_by_numbers(
  p_user_id UUID,
  p_collection_id INTEGER,
  p_numbers INTEGER[]
) RETURNS JSON
```

**Returns:**

```json
{
  "added": 5,
  "duplicates": [12, 15],
  "invalid": [999]
}
```

**Security:** SECURITY DEFINER, requires caller = `p_user_id`

---

#### `search_stickers` _(v1.3.0)_

Search stickers with filters and ownership status.

```sql
FUNCTION search_stickers(
  p_collection_id INTEGER,
  p_query TEXT,
  p_filters JSONB
) RETURNS SETOF sticker_search_result
```

**Filters:**

```json
{
  "owned": true,
  "missing": false,
  "repes": true,
  "kind": "team"
}
```

**Security:** SECURITY DEFINER, authenticated users only

---

### Trading - Discovery

#### `find_mutual_traders`

Find users with mutual trading opportunities. Sticker intent is inferred from inventory counts: a sticker is missing when the seeker has `count = 0`, and a tradeable duplicate is available when the owner has `count > 1`.

```sql
FUNCTION find_mutual_traders(
  p_user_id UUID,
  p_collection_id INTEGER,
  p_rarity TEXT DEFAULT NULL,
  p_team TEXT DEFAULT NULL,
  p_query TEXT DEFAULT NULL,
  p_min_overlap INTEGER DEFAULT 1,
  p_limit INTEGER DEFAULT 20,
  p_offset INTEGER DEFAULT 0
) RETURNS TABLE (
  match_user_id UUID,
  nickname TEXT,
  overlap_from_them_to_me BIGINT,
  overlap_from_me_to_them BIGINT,
  total_mutual_overlap BIGINT
)
```

**Security:** SECURITY DEFINER

---

#### `get_mutual_trade_detail`

Get detailed sticker lists for a trading pair. Rows are emitted with `direction = 'they_offer'` when the other user has duplicates (`count > 1`) and the current user has none (`count = 0`), and `direction = 'i_offer'` for the inverse.

```sql
FUNCTION get_mutual_trade_detail(
  p_user_id UUID,
  p_other_user_id UUID,
  p_collection_id INTEGER
) RETURNS TABLE (
  direction TEXT,
  sticker_id INTEGER,
  sticker_code TEXT,
  player_name TEXT,
  team_name TEXT,
  rarity TEXT,
  count INTEGER
)
```

**Security:** SECURITY DEFINER

---

### Trading - Proposals

#### `create_trade_proposal`

Create a new trade proposal.

```sql
FUNCTION create_trade_proposal(
  p_collection_id INTEGER,
  p_to_user UUID,
  p_message TEXT,
  p_offer_items JSONB,
  p_request_items JSONB
) RETURNS JSON
```

**Returns:**

```json
{
  "proposal_id": 123
}
```

**Security:** SECURITY DEFINER

---

#### `respond_to_trade_proposal`

Accept, reject, or cancel a proposal.

```sql
FUNCTION respond_to_trade_proposal(
  p_proposal_id INTEGER,
  p_action TEXT
) RETURNS JSON
```

**Actions:** `'accept'`, `'reject'`, `'cancel'`

**Security:** SECURITY DEFINER

---

#### `list_trade_proposals`

List inbox or outbox proposals.

```sql
FUNCTION list_trade_proposals(
  p_user_id UUID,
  p_box TEXT,
  p_limit INTEGER DEFAULT 20,
  p_offset INTEGER DEFAULT 0
) RETURNS TABLE (...)
```

**Box:** `'inbox'` or `'outbox'`

**Security:** SECURITY DEFINER

---

#### `get_trade_proposal_detail`

Get complete proposal details.

```sql
FUNCTION get_trade_proposal_detail(
  p_proposal_id INTEGER
) RETURNS JSON
```

**Security:** SECURITY DEFINER

---

### Trading - History

#### `complete_trade` _(v1.3.0)_

Mark a trade as completed.

```sql
FUNCTION complete_trade(
  p_trade_id BIGINT
) RETURNS VOID
```

**Security:** SECURITY DEFINER, only participants

---

#### `cancel_trade` _(v1.3.0)_

Cancel a trade.

```sql
FUNCTION cancel_trade(
  p_trade_id BIGINT
) RETURNS VOID
```

**Security:** SECURITY DEFINER, only participants

---

### Sticker Completion

#### `mark_team_page_complete` _(v1.4.0)_

Marks all stickers on a team page as owned (count=1) for a user. Only adds stickers that are currently missing (no row or count=0). Idempotent - returns added_count=0 if page already complete.

```sql
FUNCTION mark_team_page_complete(
  p_user_id UUID,
  p_collection_id INT,
  p_page_id INT
) RETURNS JSONB
```

**Parameters:**

- `p_user_id`: User UUID (must match authenticated user)
- `p_collection_id`: Collection ID that owns the page
- `p_page_id`: Page ID to mark complete (must be a team page)

**Returns:**

```json
{
  "added_count": 5,
  "affected_sticker_ids": [1, 5, 12, 18, 20]
}
```

**Preconditions:**

- User must be authenticated (`auth.uid()`)
- Caller must be acting on their own behalf (`p_user_id = auth.uid()`)
- Page must belong to the specified collection
- Page must be a team page (`kind = 'team'` or exactly 20 slots)

**Side Effects:**

- Inserts new rows into `user_stickers` with `count = 1` for missing stickers
- Updates existing rows where `count = 0` to `count = 1`
- Does NOT modify stickers with `count >= 1` (preserves singles and duplicates)
- Idempotent: re-running on same page returns `added_count = 0`

**Security:**

- `SECURITY DEFINER`: Runs with elevated privileges
- Auth guard: Validates `p_user_id = auth.uid()` at function start
- RLS remains enabled on `user_stickers` table
- Cross-user writes blocked by exception

**Scope:**

- **Team pages only**: Badge + manager + 18 players (20 slots)
- **Special pages**: Not supported in Phase 1 (raises exception)

**Error Cases:**

- Cross-user write: `Unauthorized: Cannot modify stickers for another user`
- Invalid page/collection: `Invalid page_id X for collection_id Y`
- Non-team page: `Only team pages are supported` (SQLSTATE `check_violation`)
- RLS violations: Standard Supabase RLS errors

**Full Implementation:**

```sql
-- Drop existing function if it exists
DROP FUNCTION IF EXISTS mark_team_page_complete(UUID, INT, INT);

-- Create the function with team page validation
CREATE OR REPLACE FUNCTION mark_team_page_complete(
    p_user_id UUID,
    p_collection_id INT,
    p_page_id INT
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO public
AS $$
DECLARE
    v_added_count INT := 0;
    v_affected_sticker_ids INT[] := ARRAY[]::INT[];
    v_page_exists BOOLEAN;
    v_page_kind TEXT;
    v_slot_count INT;
BEGIN
    -- Security: Verify the caller is acting on their own behalf
    IF p_user_id <> auth.uid() THEN
        RAISE EXCEPTION 'Unauthorized: Cannot modify stickers for another user';
    END IF;

    -- Validate that the page belongs to the collection and get page kind
    SELECT
        EXISTS(
            SELECT 1
            FROM collection_pages
            WHERE id = p_page_id
              AND collection_id = p_collection_id
        ),
        (SELECT kind FROM collection_pages WHERE id = p_page_id)
    INTO v_page_exists, v_page_kind;

    IF NOT v_page_exists THEN
        RAISE EXCEPTION 'Invalid page_id % for collection_id %', p_page_id, p_collection_id;
    END IF;

    -- Guard: Only allow team pages
    -- First try to use collection_pages.kind if available
    IF v_page_kind IS NOT NULL THEN
        -- Column exists, use it directly
        IF v_page_kind <> 'team' THEN
            RAISE EXCEPTION 'Only team pages are supported'
                USING ERRCODE = 'check_violation';
        END IF;
    ELSE
        -- Fallback: check slot count (team pages have exactly 20 slots)
        SELECT COUNT(*)
        INTO v_slot_count
        FROM page_slots
        WHERE page_id = p_page_id;

        IF v_slot_count <> 20 THEN
            RAISE EXCEPTION 'Only team pages are supported'
                USING ERRCODE = 'check_violation';
        END IF;
    END IF;

    -- Insert missing stickers (count = 0 or no row) and collect affected IDs
    WITH page_stickers AS (
        -- Get all stickers on this page that belong to the collection
        SELECT ps.sticker_id
        FROM page_slots ps
        INNER JOIN stickers s ON s.id = ps.sticker_id
        WHERE ps.page_id = p_page_id
          AND s.collection_id = p_collection_id
    ),
    missing_stickers AS (
        -- Find stickers that are missing (no row or count = 0)
        SELECT ps.sticker_id
        FROM page_stickers ps
        LEFT JOIN user_stickers us ON
            us.user_id = p_user_id
            AND us.sticker_id = ps.sticker_id
        WHERE us.sticker_id IS NULL OR us.count = 0
    ),
    inserted AS (
        -- Upsert: insert new rows or update count to 1 where it was 0
        INSERT INTO user_stickers (user_id, sticker_id, count)
        SELECT p_user_id, sticker_id, 1
        FROM missing_stickers
        ON CONFLICT (user_id, sticker_id)
        DO UPDATE SET count = 1
        WHERE user_stickers.count = 0
        RETURNING sticker_id
    )
    SELECT
        COUNT(*)::INT,
        ARRAY_AGG(sticker_id ORDER BY sticker_id)
    INTO v_added_count, v_affected_sticker_ids
    FROM inserted;

    -- Handle case where no stickers were added
    IF v_affected_sticker_ids IS NULL THEN
        v_affected_sticker_ids := ARRAY[]::INT[];
    END IF;

    RETURN jsonb_build_object(
        'added_count', v_added_count,
        'affected_sticker_ids', v_affected_sticker_ids
    );
END;
$$;

-- Revoke all permissions from public
REVOKE ALL ON FUNCTION mark_team_page_complete(UUID, INT, INT) FROM PUBLIC;

-- Grant execute to authenticated users
GRANT EXECUTE ON FUNCTION mark_team_page_complete(UUID, INT, INT) TO authenticated;

-- Add function comment
COMMENT ON FUNCTION mark_team_page_complete(UUID, INT, INT) IS
'Marks all stickers on a team page as owned (count=1) for a user. Only adds stickers that are currently missing (no row or count=0). Idempotent - returns added_count=0 if page already complete. Only supports team pages (kind=team or exactly 20 slots).';
```

---

## Triggers

### `handle_updated_at`

Automatically updates `updated_at` column on row modifications.

Applied to:

- `profiles`
- `user_stickers`
- `trade_proposals`

---

## Supabase Storage Buckets

### `sticker-images`

Stores sticker artwork.

**Structure:**

```
sticker-images/
├── {collection_id}/
│   ├── {sticker_number}-{sticker_id}.webp (300px)
│   └── thumbs/
│       └── {sticker_number}-{sticker_id}.webp (100px)
```

**Configuration:**

- Public read access
- Authenticated write only
- Max file size: 5MB
- Allowed MIME types: `image/webp`, `image/png`, `image/jpeg`

---

### `avatars`

Stores user profile avatars.

**Configuration:**

- Public read access
- Authenticated write only
- Max file size: 2MB
- Allowed MIME types: `image/webp`, `image/png`, `image/jpeg`

---

## Migration Notes

### Deployment Checklist

1. ✅ All core tables created
2. ✅ All indexes applied
3. ✅ All RLS policies active
4. ✅ All RPC functions deployed
5. ✅ Storage buckets configured
6. ⚠️ Backfill `stickers.sticker_number` before enforcing NOT NULL
7. ⚠️ Populate `collection_pages` and `page_slots` for active collections

### Performance Monitoring

Key indexes for monitoring:

- `idx_user_stickers_trading_v2` (Phase 1 high traffic)
- `idx_user_stickers_trading` (kept during transition)
- `idx_stickers_collection_filters` (trading queries)
- `idx_trade_proposals_to_user` (inbox queries)
- `idx_collection_pages_order` (album navigation)
- `idx_page_slots_page_id` (page completion queries - v1.4.0)
- `idx_user_stickers_user_collection_sticker_count` (page completion queries - v1.4.0)

---

## Performance Indexes (v1.4.0)

The following indexes optimize the `mark_team_page_complete` function and related page-based operations:

```sql
-- Indexes for mark_team_page_complete performance
-- These support fast lookups in the function's CTEs

-- Index for page_slots: quick lookup of all stickers on a given page
CREATE INDEX IF NOT EXISTS idx_page_slots_page_id
ON page_slots(page_id);

-- Composite index for page_slots: covers both columns used in joins
CREATE INDEX IF NOT EXISTS idx_page_slots_page_sticker
ON page_slots(page_id, sticker_id);

-- Index for user_stickers: fast lookup by user + collection + sticker
-- This supports the LEFT JOIN in missing_stickers CTE
CREATE INDEX IF NOT EXISTS idx_user_stickers_user_collection_sticker
ON user_stickers(user_id, collection_id, sticker_id);

-- Additional index including count for filtering count = 0
CREATE INDEX IF NOT EXISTS idx_user_stickers_user_collection_sticker_count
ON user_stickers(user_id, collection_id, sticker_id, count);

-- Index for collection_pages: validate page belongs to collection
CREATE INDEX IF NOT EXISTS idx_collection_pages_page_collection
ON collection_pages(page_id, collection_id);

-- Alternative index if collection_pages has 'id' as primary key
CREATE INDEX IF NOT EXISTS idx_collection_pages_collection
ON collection_pages(collection_id);

/*
EXPECTED QUERY PLAN SHAPE:
============================

1. Page validation (collection_pages):
   -> Index Scan using idx_collection_pages_page_collection
   -> Should be instant lookup

2. page_stickers CTE (page_slots):
   -> Index Scan using idx_page_slots_page_id
   -> Returns ~20 rows for team pages

3. missing_stickers CTE (LEFT JOIN):
   -> Nested Loop Left Join
      -> Seq Scan on page_stickers (small CTE, ~20 rows)
      -> Index Scan using idx_user_stickers_user_collection_sticker
   -> Filter on (us.sticker_id IS NULL OR us.count = 0)

4. INSERT with ON CONFLICT:
   -> Uses unique constraint on (user_id, collection_id, sticker_id)
   -> Supported by idx_user_stickers_user_collection_sticker

Overall: Should be < 10ms for typical team page (20 stickers)
Key: All joins use index scans, no table scans except tiny CTEs
*/
```

---

## Schema Version History

- **v1.3.0** (Current): Album pages, trade history, badges, enhanced sticker images
- **v1.2.0**: Complete trade proposals system
- **v1.1.0**: Trading discovery (find mutual traders)
- **v1.0.0**: Core collection and sticker management

---

**Status:** ✅ All v1.3.0 features deployed and documented
**Next:** Begin Phase 2 continuation (chat UI, history dashboard)
