-- Tables for Trade Proposals

-- trade_proposals: Header for a trade offer
CREATE TABLE trade_proposals (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    collection_id INTEGER NOT NULL REFERENCES collections(id) ON DELETE CASCADE,
    from_user UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    to_user UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'rejected', 'cancelled', 'expired')),
    message TEXT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    CONSTRAINT from_user_cannot_trade_with_self CHECK (from_user <> to_user)
);

-- trade_proposal_items: Line items for a trade (what is offered vs. requested)
CREATE TABLE trade_proposal_items (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    proposal_id BIGINT NOT NULL REFERENCES trade_proposals(id) ON DELETE CASCADE,
    sticker_id INTEGER NOT NULL REFERENCES stickers(id) ON DELETE CASCADE,
    direction TEXT NOT NULL CHECK (direction IN ('offer', 'request')),
    quantity INTEGER NOT NULL CHECK (quantity > 0)
);

-- Indexes for performance
CREATE INDEX ON trade_proposals (to_user, status, created_at DESC);
CREATE INDEX ON trade_proposals (from_user, status, created_at DESC);
CREATE INDEX ON trade_proposals (collection_id);
CREATE INDEX ON trade_proposal_items (proposal_id);

-- Trigger to automatically update `updated_at` on proposal changes
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = now();
   RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_trade_proposals_updated_at BEFORE UPDATE ON trade_proposals FOR EACH ROW EXECUTE PROCEDURE public.update_updated_at_column();
