-- =============================================================
-- CROMOS DATABASE MIGRATION
-- Album pages, sticker metadata, badges, trade chat & history
-- =============================================================

SET search_path = public;

-- -------------------------------------------------------------
-- 1. Sticker metadata enhancements
-- -------------------------------------------------------------
ALTER TABLE public.stickers
  ADD COLUMN IF NOT EXISTS sticker_number INTEGER,
  ADD COLUMN IF NOT EXISTS image_path_webp_300 TEXT,
  ADD COLUMN IF NOT EXISTS thumb_path_webp_100 TEXT;
-- TODO: backfill sticker_number/image assets before enforcing NOT NULL.

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_indexes
    WHERE schemaname = 'public'
      AND indexname = 'idx_stickers_collection_number_unique'
  ) THEN
    CREATE UNIQUE INDEX idx_stickers_collection_number_unique
      ON public.stickers (collection_id, sticker_number)
      WHERE sticker_number IS NOT NULL;
  END IF;
END $$;

-- -------------------------------------------------------------
-- 2. Album structure tables
-- -------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.collection_pages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  collection_id INTEGER NOT NULL REFERENCES public.collections (id) ON DELETE CASCADE,
  kind TEXT NOT NULL CHECK (kind IN ('team', 'special')),
  team_id INTEGER NULL REFERENCES public.collection_teams (id) ON DELETE SET NULL,
  title TEXT NOT NULL,
  order_index INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT collection_pages_kind_team_check
    CHECK (
      (kind = 'team' AND team_id IS NOT NULL) OR
      (kind = 'special' AND team_id IS NULL)
    )
);

CREATE TABLE IF NOT EXISTS public.page_slots (
  page_id BIGINT NOT NULL REFERENCES public.collection_pages (id) ON DELETE CASCADE,
  slot_index INTEGER NOT NULL,
  sticker_id INTEGER NULL REFERENCES public.stickers (id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (page_id, slot_index)
);

-- -------------------------------------------------------------
-- 3. User badges
-- -------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.user_badges (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles (id) ON DELETE CASCADE,
  badge_code TEXT NOT NULL,
  awarded_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conname = 'user_badges_user_code_unique'
      AND conrelid = 'public.user_badges'::regclass
  ) THEN
    ALTER TABLE public.user_badges
      ADD CONSTRAINT user_badges_user_code_unique UNIQUE (user_id, badge_code);
  END IF;
END $$;

-- -------------------------------------------------------------
-- 4. Trade chat and history tables
-- -------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.trade_chats (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  trade_id BIGINT NOT NULL REFERENCES public.trade_proposals (id) ON DELETE CASCADE,
  sender_id UUID NOT NULL REFERENCES public.profiles (id) ON DELETE CASCADE,
  message TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.trades_history (
  trade_id BIGINT PRIMARY KEY REFERENCES public.trade_proposals (id) ON DELETE CASCADE,
  status TEXT NOT NULL CHECK (status IN ('completed', 'cancelled')),
  completed_at TIMESTAMPTZ,
  cancelled_at TIMESTAMPTZ,
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb
);

-- -------------------------------------------------------------
-- 5. Helpful indexes
-- -------------------------------------------------------------
CREATE INDEX IF NOT EXISTS idx_collection_pages_order
  ON public.collection_pages (collection_id, order_index);

-- PRIMARY KEY on (page_id, slot_index) already serves the slot index lookup.
-- Explicit index retained for clarity per requirements.
CREATE INDEX IF NOT EXISTS idx_page_slots_page_slot
  ON public.page_slots (page_id, slot_index);

CREATE INDEX IF NOT EXISTS idx_trade_chats_trade_created_at
  ON public.trade_chats (trade_id, created_at);

-- -------------------------------------------------------------
-- 6. Row Level Security policies
-- -------------------------------------------------------------
ALTER TABLE public.collection_pages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.page_slots ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_badges ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.trade_chats ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.trades_history ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE policyname = 'Allow read access to album pages'
      AND tablename = 'collection_pages'
      AND schemaname = 'public'
  ) THEN
    EXECUTE 'CREATE POLICY "Allow read access to album pages" ON public.collection_pages FOR SELECT USING (true);';
  END IF;
END $$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE policyname = 'Allow read access to page slots'
      AND tablename = 'page_slots'
      AND schemaname = 'public'
  ) THEN
    EXECUTE 'CREATE POLICY "Allow read access to page slots" ON public.page_slots FOR SELECT USING (true);';
  END IF;
END $$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE policyname = 'User badge ownership select'
      AND tablename = 'user_badges'
      AND schemaname = 'public'
  ) THEN
    EXECUTE 'CREATE POLICY "User badge ownership select" ON public.user_badges FOR SELECT USING (auth.uid() = user_id);';
  END IF;
END $$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE policyname = 'Trade chat participant read'
      AND tablename = 'trade_chats'
      AND schemaname = 'public'
  ) THEN
    EXECUTE 'CREATE POLICY "Trade chat participant read" ON public.trade_chats FOR SELECT USING (EXISTS (SELECT 1 FROM public.trade_proposals tp WHERE tp.id = trade_id AND (tp.from_user = auth.uid() OR tp.to_user = auth.uid())));';
  END IF;
END $$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE policyname = 'Trade chat participant insert'
      AND tablename = 'trade_chats'
      AND schemaname = 'public'
  ) THEN
    EXECUTE 'CREATE POLICY "Trade chat participant insert" ON public.trade_chats FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM public.trade_proposals tp WHERE tp.id = trade_id AND (tp.from_user = auth.uid() OR tp.to_user = auth.uid())) AND sender_id = auth.uid());';
  END IF;
END $$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE policyname = 'Trade history participant read'
      AND tablename = 'trades_history'
      AND schemaname = 'public'
  ) THEN
    EXECUTE 'CREATE POLICY "Trade history participant read" ON public.trades_history FOR SELECT USING (EXISTS (SELECT 1 FROM public.trade_proposals tp WHERE tp.id = trade_id AND (tp.from_user = auth.uid() OR tp.to_user = auth.uid())));';
  END IF;
END $$;

-- User badges are service-managed; block direct writes.
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE policyname = 'User badge no direct writes'
      AND tablename = 'user_badges'
      AND schemaname = 'public'
  ) THEN
    EXECUTE 'CREATE POLICY "User badge no direct writes" ON public.user_badges FOR ALL USING (false) WITH CHECK (false);';
  END IF;
END $$;

-- Disallow direct writes to album structure from clients.
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE policyname = 'Collection pages no client writes'
      AND tablename = 'collection_pages'
      AND schemaname = 'public'
  ) THEN
    EXECUTE 'CREATE POLICY "Collection pages no client writes" ON public.collection_pages FOR ALL USING (false) WITH CHECK (false);';
  END IF;
END $$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE policyname = 'Page slots no client writes'
      AND tablename = 'page_slots'
      AND schemaname = 'public'
  ) THEN
    EXECUTE 'CREATE POLICY "Page slots no client writes" ON public.page_slots FOR ALL USING (false) WITH CHECK (false);';
  END IF;
END $$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE policyname = 'Trade chat no direct updates'
      AND tablename = 'trade_chats'
      AND schemaname = 'public'
  ) THEN
    EXECUTE 'CREATE POLICY "Trade chat no direct updates" ON public.trade_chats FOR UPDATE USING (false) WITH CHECK (false);';
  END IF;
END $$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE policyname = 'Trade history no direct writes'
      AND tablename = 'trades_history'
      AND schemaname = 'public'
  ) THEN
    EXECUTE 'CREATE POLICY "Trade history no direct writes" ON public.trades_history FOR ALL USING (false) WITH CHECK (false);';
  END IF;
END $$;

-- -------------------------------------------------------------
-- 7. RPC functions
-- -------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.bulk_add_stickers_by_numbers(
  p_user_id UUID,
  p_collection_id INTEGER,
  p_numbers INTEGER[]
) RETURNS JSON AS $$
DECLARE
  v_requester UUID := auth.uid();
  v_result JSON;
  v_added INTEGER := 0;
  v_duplicates INTEGER[] := ARRAY[]::INTEGER[];
  v_invalid INTEGER[] := ARRAY[]::INTEGER[];
BEGIN
  IF v_requester IS NULL THEN
    RAISE EXCEPTION 'bulk_add_stickers_by_numbers requires authentication';
  END IF;

  IF v_requester <> p_user_id THEN
    RAISE EXCEPTION 'Forbidden: cannot update inventory for another user';
  END IF;

  IF p_numbers IS NULL OR array_length(p_numbers, 1) IS NULL THEN
    RETURN json_build_object('added', 0, 'duplicates', v_duplicates, 'invalid', v_invalid);
  END IF;

  WITH input_numbers AS (
    SELECT value AS sticker_number, COUNT(*) AS occurrences
    FROM UNNEST(p_numbers) AS value
    GROUP BY value
  ),
  resolved AS (
    SELECT i.sticker_number,
           i.occurrences,
           s.id AS sticker_id
    FROM input_numbers i
    LEFT JOIN public.stickers s
      ON s.collection_id = p_collection_id
     AND s.sticker_number = i.sticker_number
  ),
  existing_inventory AS (
    SELECT r.sticker_id,
           r.sticker_number,
           r.occurrences
    FROM resolved r
    JOIN public.user_stickers us
      ON us.user_id = p_user_id
     AND us.sticker_id = r.sticker_id
    WHERE r.sticker_id IS NOT NULL
  ),
  inserted AS (
    INSERT INTO public.user_stickers (user_id, sticker_id, count)
    SELECT p_user_id, r.sticker_id, r.occurrences
    FROM resolved r
    WHERE r.sticker_id IS NOT NULL
      AND NOT EXISTS (
        SELECT 1
        FROM public.user_stickers us
        WHERE us.user_id = p_user_id
          AND us.sticker_id = r.sticker_id
      )
    RETURNING sticker_id, count
  ),
  updated AS (
    UPDATE public.user_stickers us
    SET count = us.count + ei.occurrences,
        updated_at = NOW()
    FROM existing_inventory ei
    WHERE us.user_id = p_user_id
      AND us.sticker_id = ei.sticker_id
    RETURNING us.sticker_id
  )
  SELECT
    COALESCE((SELECT SUM(count) FROM inserted), 0),
    COALESCE((SELECT array_agg(DISTINCT ei.sticker_number) FROM existing_inventory ei), ARRAY[]::INTEGER[]),
    COALESCE((SELECT array_agg(r.sticker_number) FROM resolved r WHERE r.sticker_id IS NULL), ARRAY[]::INTEGER[])
  INTO v_added, v_duplicates, v_invalid;

  v_result := json_build_object(
    'added', v_added,
    'duplicates', v_duplicates,
    'invalid', v_invalid
  );

  RETURN v_result;
END;
$$ LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public;

CREATE OR REPLACE FUNCTION public.get_completion_report(
  p_user_id UUID,
  p_collection_id INTEGER
) RETURNS JSON AS $$
DECLARE
  v_requester UUID := auth.uid();
  v_payload JSON;
BEGIN
  IF v_requester IS NULL THEN
    RAISE EXCEPTION 'get_completion_report requires authentication';
  END IF;

  IF v_requester <> p_user_id THEN
    RAISE EXCEPTION 'Forbidden: cannot view completion report for another user';
  END IF;

  SELECT json_build_object(
    'collection_id', p_collection_id,
    'pages', COALESCE(json_agg(
      json_build_object(
        'page_id', cp.id,
        'kind', cp.kind,
        'title', cp.title,
        'order_index', cp.order_index,
        'missing', COALESCE(missing_numbers, '[]'::JSON),
        'repes', COALESCE(duplicate_numbers, '[]'::JSON)
      )
      ORDER BY cp.order_index
    ), '[]'::JSON)
  )
  INTO v_payload
  FROM (
    SELECT
      cp.id,
      cp.kind,
      cp.title,
      cp.order_index,
      to_json(COALESCE(array_remove(array_agg(DISTINCT CASE WHEN COALESCE(us.count, 0) = 0 THEN s.sticker_number END), NULL), ARRAY[]::INTEGER[])) AS missing_numbers,
      to_json(COALESCE(array_remove(array_agg(DISTINCT CASE WHEN COALESCE(us.count, 0) > 1 THEN s.sticker_number END), NULL), ARRAY[]::INTEGER[])) AS duplicate_numbers
    FROM public.collection_pages cp
    LEFT JOIN public.page_slots ps
      ON ps.page_id = cp.id
    LEFT JOIN public.stickers s
      ON s.id = ps.sticker_id
    LEFT JOIN public.user_stickers us
      ON us.sticker_id = s.id
     AND us.user_id = p_user_id
    WHERE cp.collection_id = p_collection_id
    GROUP BY cp.id, cp.kind, cp.title, cp.order_index
    ORDER BY cp.order_index
  ) cp;

  RETURN COALESCE(v_payload, json_build_object('collection_id', p_collection_id, 'pages', '[]'::JSON));
END;
$$ LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public;

CREATE OR REPLACE FUNCTION public.search_stickers(
  p_collection_id INTEGER,
  p_query TEXT DEFAULT NULL,
  p_filters JSONB DEFAULT '{}'::JSONB
) RETURNS TABLE (
  sticker_id INTEGER,
  sticker_number INTEGER,
  code TEXT,
  player_name TEXT,
  rarity TEXT,
  team_id INTEGER,
  team_name TEXT,
  page_id BIGINT,
  page_title TEXT,
  page_kind TEXT,
  slot_index INTEGER,
  owned_count INTEGER,
  is_missing BOOLEAN,
  is_duplicate BOOLEAN
) AS $$
DECLARE
  v_requester UUID := auth.uid();
  v_filters JSONB := COALESCE(p_filters, '{}'::JSONB);
  v_filter_owned BOOLEAN := NULL;
  v_filter_missing BOOLEAN := NULL;
  v_filter_repes BOOLEAN := NULL;
  v_filter_kind TEXT := NULL;
  v_has_status_filter BOOLEAN := FALSE;
BEGIN
  IF v_requester IS NULL THEN
    RAISE EXCEPTION 'search_stickers requires authentication';
  END IF;

  IF v_filters ? 'owned' THEN
    v_filter_owned := (v_filters->>'owned')::BOOLEAN;
  END IF;

  IF v_filters ? 'missing' THEN
    v_filter_missing := (v_filters->>'missing')::BOOLEAN;
  END IF;

  IF v_filters ? 'repes' THEN
    v_filter_repes := (v_filters->>'repes')::BOOLEAN;
  END IF;

  IF v_filters ? 'kind' THEN
    v_filter_kind := lower(v_filters->>'kind');
  END IF;

  v_has_status_filter := COALESCE(v_filter_owned, FALSE)
    OR COALESCE(v_filter_missing, FALSE)
    OR COALESCE(v_filter_repes, FALSE);

  RETURN QUERY
  WITH sticker_base AS (
    SELECT
      s.id AS sticker_id,
      s.sticker_number,
      s.code,
      s.player_name,
      s.rarity,
      s.team_id,
      ct.team_name,
      cp.id AS page_id,
      cp.title AS page_title,
      cp.kind AS page_kind,
      ps.slot_index,
      COALESCE(us.count, 0) AS owned_count
    FROM public.stickers s
    LEFT JOIN public.page_slots ps
      ON ps.sticker_id = s.id
    LEFT JOIN public.collection_pages cp
      ON cp.id = ps.page_id
    LEFT JOIN public.collection_teams ct
      ON ct.id = s.team_id
    LEFT JOIN public.user_stickers us
      ON us.sticker_id = s.id
     AND us.user_id = v_requester
    WHERE s.collection_id = p_collection_id
      AND (
        p_query IS NULL
        OR p_query = ''
        OR s.code ILIKE '%' || p_query || '%'
        OR s.player_name ILIKE '%' || p_query || '%'
        OR (s.sticker_number::TEXT) ILIKE '%' || p_query || '%'
      )
      AND (
        v_filter_kind IS NULL
        OR (cp.kind IS NOT NULL AND lower(cp.kind) = v_filter_kind)
      )
  )
  SELECT
    sb.sticker_id,
    sb.sticker_number,
    sb.code,
    sb.player_name,
    sb.rarity,
    sb.team_id,
    sb.team_name,
    sb.page_id,
    sb.page_title,
    sb.page_kind,
    sb.slot_index,
    sb.owned_count,
    (sb.owned_count = 0) AS is_missing,
    (sb.owned_count > 1) AS is_duplicate
  FROM sticker_base sb
  WHERE
    (
      NOT v_has_status_filter
      OR (
        (v_filter_owned IS TRUE AND sb.owned_count > 0)
        OR (v_filter_missing IS TRUE AND sb.owned_count = 0)
        OR (v_filter_repes IS TRUE AND sb.owned_count > 1)
      )
    );
END;
$$ LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public;

CREATE OR REPLACE FUNCTION public.complete_trade(p_trade_id BIGINT)
RETURNS VOID AS $$
DECLARE
  v_requester UUID := auth.uid();
  v_trade public.trade_proposals%ROWTYPE;
BEGIN
  IF v_requester IS NULL THEN
    RAISE EXCEPTION 'complete_trade requires authentication';
  END IF;

  SELECT * INTO v_trade
  FROM public.trade_proposals tp
  WHERE tp.id = p_trade_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Trade % not found', p_trade_id;
  END IF;

  IF v_requester NOT IN (v_trade.from_user, v_trade.to_user) THEN
    RAISE EXCEPTION 'Forbidden: user is not a participant of trade %', p_trade_id;
  END IF;

  -- Update proposal status if it has not been cancelled
  IF v_trade.status <> 'cancelled' THEN
    UPDATE public.trade_proposals
    SET status = 'accepted',
        updated_at = NOW()
    WHERE id = p_trade_id
      AND status <> 'cancelled';
  END IF;

  INSERT INTO public.trades_history (trade_id, status, completed_at, cancelled_at)
  VALUES (p_trade_id, 'completed', NOW(), NULL)
  ON CONFLICT (trade_id)
  DO UPDATE SET
    status = 'completed',
    completed_at = NOW(),
    cancelled_at = NULL,
    metadata = public.trades_history.metadata;
END;
$$ LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public;

CREATE OR REPLACE FUNCTION public.cancel_trade(p_trade_id BIGINT)
RETURNS VOID AS $$
DECLARE
  v_requester UUID := auth.uid();
  v_trade public.trade_proposals%ROWTYPE;
BEGIN
  IF v_requester IS NULL THEN
    RAISE EXCEPTION 'cancel_trade requires authentication';
  END IF;

  SELECT * INTO v_trade
  FROM public.trade_proposals tp
  WHERE tp.id = p_trade_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Trade % not found', p_trade_id;
  END IF;

  IF v_requester NOT IN (v_trade.from_user, v_trade.to_user) THEN
    RAISE EXCEPTION 'Forbidden: user is not a participant of trade %', p_trade_id;
  END IF;

  UPDATE public.trade_proposals
  SET status = 'cancelled',
      updated_at = NOW()
  WHERE id = p_trade_id;

  INSERT INTO public.trades_history (trade_id, status, cancelled_at, completed_at)
  VALUES (p_trade_id, 'cancelled', NOW(), NULL)
  ON CONFLICT (trade_id)
  DO UPDATE SET
    status = 'cancelled',
    cancelled_at = NOW(),
    completed_at = NULL,
    metadata = public.trades_history.metadata;
END;
$$ LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public;

-- -------------------------------------------------------------
-- 8. Function grants
-- -------------------------------------------------------------
GRANT EXECUTE ON FUNCTION public.bulk_add_stickers_by_numbers(UUID, INTEGER, INTEGER[]) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_completion_report(UUID, INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION public.search_stickers(INTEGER, TEXT, JSONB) TO authenticated;
GRANT EXECUTE ON FUNCTION public.complete_trade(BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.cancel_trade(BIGINT) TO authenticated;













